<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>EE 460N: Problem Set 3 Solution</title>
<link rel="StyleSheet" type="text/css" href="../../main.css" />
<link rel="StyleSheet" type="text/css" href="../probs.css" />
</head>
<body>
<center>
<h2>
Department of Electrical and Computer Engineering</h2></center>

<center>
<h3>The University of Texas at Austin</h3></center>
EE 460N, Fall 2013
<br />Problem Set 4 Solutions
<br />Aater Suleman, Instructor
<br />Stephen Pruett, Abhishek Agarwal, Chirag Sakhuja, TAs
<h2>Problem Set 4 Solutions</h2>
<ol class="questions">

<li><!-- Begin Question -->
&nbsp;<br />
<ol>
<li>Size of a page is 4KB.</p>
<p>Number of bits of address required to calculate the offset within
a page is 12.</p>
<p>Number of bits remaining in address is 20. This means there are 2<sup>20</sup> pages in virtual memory.</p>
</li>
<li>
<p>Number of bytes in physical memory is 128MB = 2<sup>27</sup> bytes.</p>
<p>Number of bytes per frame is 2<sup>12</sup> so number of frames in memory is <span class="equation">2<sup>27</sup> &divide; 2<sup>12</sup> = 2<sup>15</sup></span> frames in physical memory.</p>
</li>
<li>
<p>One level page table means one PTE per page. 2<sup>20</sup> pages in virtual memory with each PTE as 4 bytes so <span class="equation">4 &times; 2<sup>20</sup> = 2<sup>22</sup> = 4MB</span> needed for page table.</p>
</li>
</ol>
</li><!-- End of Question -->

<li><!-- Begin Question -->
&nbsp;<br />
<ol>
<li>Size of a page is 4KB.</p>
<p>Number of bits of address required to calculate the offset within a page is 12.</p>
<p>Number of bits remaining in address is 20. This means there are 2<sup>20</sup> pages in virtual memory.</p>
<p>One level page table means one PTE per page. 2<sup>20</sup> pages in virtual memory with each PTE as 4 bytes so <span class="equation">4 &times; 2<sup>20</sup> = 2<sup>22</sup> = 4MB</span> needed for page table.</p>
</li>
<li>Size of offset into page directory is 10 bits, so there are 2<sup>10</sup> entries in the page directory.
<p>Each entry points to beginning of unique page tables, so there are <span class="equation">2<sup>10</sup> + 1 = 1025</span> page tables.
<p>Each page table contains 2<sup>10</sup> PTEs, each of which is 4 bytes. Therefore <span class="equation">1025 &times; 2<sup>10</sup> &times; 4 = 4100KB</span> needed for page tables.</p>
</li>
<li>Two-level page table is better. There is more overhead to keep track of the page directory, but this allows the other page tables to be in virtual memory. Thus the only table that must persistently be in memory is the 1024 element page directory.</li>
</ol>
</li><!-- End of Question -->

<li><!-- Begin Question -->
&nbsp;<br />
<table>
<thead>
<tr><th>Reference</th><th>TLB hit</th><th>Page Fault</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>X</td><td></td></tr>
<tr><td>13</td><td>X</td><td></td></tr>
<tr><td>5</td><td></td><td></td></tr>
<tr><td>2</td><td></td><td></td></tr>
<tr><td>14</td><td></td><td>X</td></tr>
<tr><td>14</td><td>X</td><td></td></tr>
<tr><td>13</td><td></td><td></td></tr>
<tr><td>6</td><td></td><td>X</td></tr>
<tr><td>6</td><td>X</td><td></td></tr>
<tr><td>13</td><td>X</td><td></td></tr>
<tr><td>15</td><td></td><td>X</td></tr>
<tr><td>14</td><td></td><td></td></tr>
<tr><td>15</td><td>X</td><td></td></tr>
<tr><td>13</td><td>X</td><td></td></tr>
<tr><td>4</td><td></td><td>X</td></tr>
<tr><td>3</td><td></td><td>X</td></tr>
</tbody>
</table>
<p>TLB hit rate = 7/16.</p>
<p>TLB contains entries for pages 3, 4, and 13.</p>
<p>Solutions for the final contents of the frames of physical memory may differ 
slightly depending on what order the initially empty frames were allocated; however, 
no page should appear in more than one frame.  Possible answers are shown below.</p>
<table>
<tr><td>Frame 0</td><td>Page 14 (or 6 or 15)</td></tr>
<tr><td>Frame 1</td><td>Page 13</td></tr>
<tr><td>Frame 2</td><td>Page 3</td></tr>
<tr><td>Frame 3</td><td>Page 2</td></tr>
<tr><td>Frame 4</td><td>Page 6 (or 14 or 15)</td></tr>
<tr><td>Frame 5</td><td>Page 4</td></tr>
<tr><td>Frame 6</td><td>Page 15 (or 6 or 14)</td></tr>
<tr><td>Frame 7</td><td>Page Table</td></tr>
</table>
</li><!-- End Question -->


<li><!-- Begin Question -->
<p>Size of a page is 512 bytes.</p>
<p>Number of bits of address required to calculate the offset within
a page is 9.</p>
<p>Number of frames in physical memory is <span class="equation">(8K bytes) &divide; (512 bytes) = 2<sup>13</sup> &divide; 2<sup>9</sup> = 2<sup>4</sup></span>.</p>
<p>Size of PFN is 4 bits.</p>
<p>Size of PTE equals <span class="equation">1 (Valid) + 1 (Modified) + 2 (access control) + 4 (PFN)
= 8 bits = 1 byte</span>.</p>
<p>Number of virtual pages in System Space is <span class="equation">(3 &times; 2<sup>12</sup>) &divide; (2<sup>9</sup>) = 24</span> pages.</p>
<p>Size of System Page Table is <span class="equation">24 &times; 1 byte = 24 bytes = 24 &times; 8 bits = 192 bits</span>.</p>
</li><!-- End of Question -->


<li><!-- Begin Question -->
<p>We can determine from the given information that:</p>
<ul>
<li>A Virtual Address (VA) is 16 bits (2<sup>16</sup> = 64KB)</li>
<li>A Physical Address (PA) is 12 bits (2<sup>12</sup> = 4KB)</li>
<li>The number of bits for the offset is 8 (2<sup>8</sup> = 256 bytes)</li>
</ul>
<p>The breakdown for a Virtual Address (VA) must be:</p>
<ul>
<li>VA[15:14] (2 bits) : Denotes the region of memory (P0, P1, System)</li>
<li>VA[13:8] (6 bits) : The Virtual Page Number (VPN)</li>
<li>VA[7:0] (8 bits) : The offset</li>
</ul>

<p>The breakdown for a Physical Address (PA) must be:</p>
<ul>
<li>PA[11:8] (4 bits) : The Page Frame Number (PFN)</li>
<li>PA[7:0] (8 bits) : The offset</li>
</ul>

<ol type="a">
<li><p>Answer: <code>x825C</code></p>
<p>Given the VAX 2-level translation scheme, we know that this VA must be in 
system space.  Therefore, the top 2 bits of the VA (VA[15:14]) must be <code>10</code> 
(in binary).  We also know that the offset of the VA is the same as the offset 
of the PA, so the bottom 8 bits of the VA (VA[7:0]) must be <code>x5C</code> (<code>01011100</code> in binary).  
Now, all we have to figure out is the 6 bit Virtual Page Number (VPN).  It 
was given that the 1st access to physical memory (let's call this PA1) was at 
location <code>x108</code>.  Once again, given the VAX 2-level translation scheme, we know 
that <span class="equation">PA1 = SBR + (size of PTE in bytes) &times; VPN</span>. Solving this equation for VPN we get
<span class="equation">VPN = (PA1 - SBR) &divide; (size of PTE in bytes)</span>.</p>
<p>It was given that PA1 is <code>x108</code>, SBR is <code>x100</code>, and the size of a PTE is 4 bytes.  Therefore, 
the VPN is <code>x2</code> (<code>000010</code> in binary).  The complete VA is therefore <code>10 000010 01011100</code> (in binary) 
which is <code>x825C</code>.</p>
</li>
<li><p>Answer: <code>x80000009</code></p>
<p>The contents of physical address <code>x45C</code> (the 2nd access to physical memory) is a PTE.  
We know that a PTE is a 32 bit value that consists of 1 valid bit (PTE[31]), and 
a 4-bit PFN (PTE[3:0]).  All other bits of the PTE (PTE[30:4]) are 0.  The contents 
of this PTE are used to form the address of the 3rd access to physical memory (<code>x942</code>).  
Therefore, the PFN bits of the PTE must be x9, and the valid bit must be 1.  This 
implies that the PTE is <code>x80000009</code>.</p>
</li>
<li><p>Answer <code>x0342</code></p>
<p>First, we must determine if this VA is in P0 space or P1 space.  To determine this, 
we have to figure out if P0BR or P1BR was used to compute the virtual address <code>x825C</code> 
(the answer to part a).  It was given that P0BR is <code>x8250</code>, and that P1BR is <code>x8350</code>.  
Since <code>x8350</code> is greater than <code>x825C</code>, we know that we could not have used P1BR to 
compute <code>x825C</code>, and therefore we must have used P0BR which means the VA is in P0 space.  
Therefore, the top 2 bits of the virtual address (VA[15:14]) must be <code>00</code> (in binary).  
We also know that the offset of the VA is the same as the offset of the PA, so the 
bottom 8 bits of the VA (VA[7:0]) must be <code>x42</code> (<code>01000010</code> in binary).  Now, all we have 
to figure out is the 6 bit Virtual Page Number (VPN).  Once again, given the VAX 2-level 
translation scheme, we know that <span class="equation"><code>x825C</code> = P0BR + ((size of PTE in bytes) &times; VPN )</span>.</p>
<p>Solving this equation for VPN we get <span class="equation">VPN = (<code>x825C</code> - P0BR) &divide; (size of PTE in bytes)</span>.</p>
<p>It was given that P0BR is <code>x8250</code>, and the size of a PTE is 4 bytes.  Therefore, the 
VPN is <code>x3</code> (<code>000011</code> in binary).  The complete VA is therefore <code>00 000011 01000010</code> 
(in binary) which is <code>x0342</code>.</p>
</li>
</ol>
</li><!-- End of Question -->



<li><!-- Begin Question -->
<ol type="a">
<li>
<span class="equation"># virtual pages = virtual address space &divide; size of page = 2<sup>12</sup> Bytes &divide; 2<sup>5</sup> Bytes/page = 
2<sup>7</sup> pages</span>
</li>

<li>
<p><span class="equation"># physical frames = physical address space &divide; size of frame = 2<sup>9</sup>Bytes &divide; 2<sup>5</sup> Bytes/frame = 
2<sup>4</sup> frames</span>. Therefore, 4 bits are needed to specify the PFN.</p>
<p><span class="equation">Size of PTE = Valid bit + Modified bit + access control bits + PFN bits = 1 + 1 + 2 + 4 = 8 bits (1 Byte)</span></p>
</li>
<li><p><span class="equation">User space = (3/4) &times; Virtual address space = (3/4) &times; 2<sup>7</sup> pages = 3 &times; 2<sup>5</sup> pages</span>. Each 
page of user space will have a PTE in the user space page table.</p>
<p>Size of user page table is <span class="equation"># of entries &times; size of PTE = (3 &times; 2<sup>5</sup> entries) &times; 1 Byte/entry = 96 Bytes</span>.</p>
<p><span class="equation"># of pages = 96 Bytes &divide; 2<sup>5</sup> Bytes/page = 3 pages</span>.</p>
</li>
<li>
<p>We'll use the prefix &ldquo;b&rdquo; to indicate a binary number in this solution. Also, for clarity, we will call 
the virtual address <code>x7AC</code> the virtual address of <var>X</var> (VA_X).</p>

Virtual address VA_X = <code>x7AC</code><br />
The three parts of this virtual address are:<br />
VA_X[11:10]: <code>b01</code> (indicates that this is an address in user space)<br />
VA_X[11:5] (7 bits): Virtual Page Number = <code>b0111101</code><br />
VA_X[4:0] Offset within page: <code>b01100</code><br />

<ul>
<li><var>X</var> is on page <code>x03D</code> of user space</li>
<li>VA of the PTE of the page containing x is VA_PTE_X = PTBR + (<code>x03D</code> &times; 1) = <code>x380</code> + <code>x03D</code> = <code>x3BD</code>.</li>
<li>Virtual page of System Space of PTE is VA_PTE_X[11:5] = <code>x01D</code>.</li>
<li>PA of the PTE of this page of System Space is PA_PTE_PTE = SBR + VA_PTE_X[11:5] &times; 1 = <code>x1E0</code> + <code>x01D</code> = <code>x1FD</code>.</li>
<li>The PTE of this page of System Space is: <br />
PTE_PTE_X = Memory[<code>x1FD</code>] = <code>xB8</code><br />
PFN_PTE_X = PTE_PTE_X[3:0] = <code>x8</code><br />
PA of the PTE of the page containing <var>X</var>:<br />
PA_PTE_X = PFN_PTE_X concatenated with VA_PTE_X[4:0] = <code>x11D</code><br />
PTE_X = Memory[<code>x11D</code>] = <code>x83</code><br />
PFN_X = PTE_X[3:0] = <code>x3</code><br />
PA_X = PFN_X concantenated with VA_X[4:0] = <code>x06C</code>
</li>
</ul>
</li>
</ol>
</li><!-- End Question -->


<li><!-- Begin Question -->
<p>We'll use the prefix &ldquo;b&rdquo; to indicate a binary number in this solution.</p>

Virtual address VA_X = <code>x3456789A</code><br />
The three parts of this virtual address are:<br />
VA_X[31:30]: <code>b00</code> (indicates that this is an address in P0 space)<br />
VA_X[29:9] (21 bits): Virtual Page Number = <code>b 11 0100 0101 0110 0111 100</code> (<code>x1A2B3C</code>)<br />
VA_X[8:0] Offset within page: <code>b010011010</code><br />
<ul>
<li>x is on page <code>x1A2B3C</code> of P0 space</li>
<li>VA of the PTE of the page containing <var>X</var>:<br />
VA_PTE_X = P0BR + (<code>x1A2B3C</code> &times; 4) = <code>x8AC40000</code> + <code>x68ACF0</code> = <code>x8B2CACF0</code></li>
<li>Virtual page of System Space of PTE is VA_PTE_X[29:9] = <code>x59656</code> </li>
<li>PA of the PTE of this page of System Space is PA_PTE_PTE = SBR + VA_PTE_X[29:9] &times; 4 = <code>x22D958</code></li>
<li>The PTE of this page of System Space is PTE_PTE_X = Memory[<code>x22D958</code>] = <code>x800F5D37</code><br />
PFN_PTE_X = PTE_PTE_X[20:0] = <code>xF5D37</code><br />
PA of the PTE of the page containing <var>X</var>:<br />
PA_PTE_X = PFN_PTE_X concatenated with VA_PTE_X[8:0] = <code>x1EBA6EF0</code><br />
PTE_X = Memory[<code>x1EBA6EF0</code>] = <code>x80000A72</code><br />
PFN_X = PTE_X[20:0] = <code>xA72</code><br />
PA_X = PFN_X concantenated with VA_X[8:0] = <code>x14E49A</code></li>
</ul>
</li><!-- End Question -->     



<li><!-- Begin Question -->
<p>Including instruction fetch, every instruction can generate a page
fault.  Ignoring instruction fetch, LDB, LDW, STB, STW, TRAP, RTI can
generate a page fault (If the trap vector table or system stack is
always in physical memory, then the TRAP or RTI won't generate a page
fault).</p>
<p>Including the instruction fetch, RTI can generate the maximum number
of page faults (3) and LDB, LDW, STB, STW, TRAP can generate the
next most number of page faults (2). (Points will not be deducted for RTI)</p>
</li><!-- End Question -->

<li><!-- Begin Question -->
<p>An 8KB cache size with a 8B line size, in a 4-way set associative
cache means there are <span class="equation">8KB &divide; (4 &times; 8B) = 256</span> sets in the cache.</p>
<p>Since there are 256 or 2<sup>8</sup> sets, 8 bits are required to index
into the correct set. Since there are 8B or 2<sup>3</sup> bytes in a cache line,
3 bits are required to find the correct byte within a block. Given a 24-bit address space, this leaves <span class="equation">24 - 8 - 3 = 13</span> bits left
over for the tag store. Additionally, the tag store must hold 2 bits
for the V/NV replacement policy and 1 valid bit. This means each cache
line must have a 16-bit tag store associated with it. 2B of tag store
times (256 &times; 4) cache lines in the cache means that the tag store, in total
takes up 2048 bytes, which is <span class="answer">16384 bits</span></p>

</li><!-- End Question -->

<li><!-- Begin Question -->
<p>The size of the tag store is <span class="equation">2<sup>12</sup> + 2<sup>8</sup></span>. We know that the size of 
the tag store can be given as the product of number of sets and number of bits per set.</p>
<p>We also know that address space is 16-bits. Hence,
<span class="equation"><var>tag</var> + <var>index</var> + <var><abbr title="Byte within block">bib</abbr></var> = 16</span></p>
<p>In order to find <var>bib</var>, we need to find <var>index</var> and <var>tag</var>.
The following bits are necessary for each set of the tag store:</p>
<ul>
<li>1 bit for LRU (remember: you only need one bit per set for a 2-way associative cache)</li>
<li>2 valid bits</li>
<li>2 dirty bits</li>
<li>2 &times; <var>tag</var> tag bits</li>
</ul>
<p>Total number of bits per set is <span class="equation">5 + 2 &times; <var>tag</var></span>. An important conclusion that can be drawn is that number of bits per set will always 
be an odd number.</p>
<p>We will also use the fact that number of sets is always a power of 2 (since it is 
indexed using an integer number of bits). Given the size of the tag store, <var>index</var> has 
to be a number less than 8 (the size of the tag store is indivisible by 2<sup>9</sup> or greater).</p>
<p>The only value of <var>index</var> that fits both criterion is 8. Therefore:</p>

<div class="equation">Number of sets = 2<sup>8</sup> = 256</div>
<div class="equation">Bits per row = 4352 &divide; 256 = 17</div>
<div class="equation">17 = 5 + 2 &times; <var>tag</var> &rArr; <var>tag</var> = 6</div>
<div class="equation">6 + 8 + <var>bib</var> = 16 &rArr; <var>bib</var> = 2</div>
<p>Hence, the cache block size is <span class="answer">4 bytes</span></p>
</li><!-- End of Question -->

<li><!-- Begin Question -->
<div class="equation"><var>average_access_time_per_instruction</var>
= 1 &times; instruction_access_time + 0.3 &times; data_access_time</div>

<p>We can use the following equations in both part a and part b to compute 
the instruction and data access time.</p>

<div class="equation"><var>instruction_access_time</var> = 1 + 0.05 &times; (6 + 0.15 &times; mem_latency)</div>
<div class="equation"><var>data_access_time</var> = 1 + 0.10 &times; (6 + 0.25 &times; mem_latency)</div>

<ol>
<li>
<p>We need to calculate the memory latency. Since each cache block is 8 
words, it will take 8 accesses to get a cache block from memory.</p>
<pre>    
(-)(...)(-)
        (-)(...)(-)
                (-)(...)(-)
                        (-)(...)(-)
                                (-)(...)(-)
                                        (-)(...)(-)
                                                (-)(...)(-)
                                                        (-)(...)(-)

|&lt;---------------------- 169 cycles -----------------------------&gt;|
</pre>

<p>Using the equations, we get 2.5675 cycles for <var>instruction_access_time</var> and 
5.825 for <var>data_access_time</var>.</p>

<p>The average latency is <span class="equation">2.5675 + 0.3 &times; 5.825 = <span class="answer">4.315 cycles</span></span></p>
</li>
<li>
<p>We again need to compute the memory latency:</p>
<pre>
(-)(.............)(-)
   (-)(.............)(-)
      (-)(.............)(-)
         (-)(.............)(-)
                  (-)(...........)(-)
                     (-)(...........)(-)
                        (-)(...........)(-)
                           (-)(...........)(-)

|&lt;--------21-----&gt;&lt;1&gt;&lt;-----20----&gt;&lt;---- 4 ---&gt;|
</pre>
<p>So the mem_latency is 46 cycles. Again using the equations, the 
instruction_access_time is 1.645 and data_acces_time is 2.75.</p>

<p>The average latency is <span class="equation">1.645 + 2.75 &times; 0.3 = <span class="answer">2.47 cycles</span></span></p>
</li>
<p> 
<li>
<p> We need to compute memory latency for 8-way interleaving
<pre>
(-)(.............)(-)
   (-)(.............)(-)
      (-)(.............)(-)
         (-)(.............)(-)
            (-)(...........)(-)
               (-)(...........)(-)
                  (-)(...........)(-)
                     (-)(...........)(-)
|--------21-------|--------8-----------|
</pre>
<p> So memory latency is 29 cycles. Using the equations, we get
    the instruction_access_time as 1.517 and data_acces_time as 2.325.
<p> The average latency is 1.517 + .3 * 2.325 = 2.215
</li>
<li>
<p>The improvement is <span class="equation">(4.315 - 2.47) &divide; 4.315 = 0.4276</span> Therefore, the average latency improves by <span class="answer">42.76%</span></p>
</li>
</ol>
</li><!-- End Question -->

<li><!-- Begin Question -->
We assume that the address is 12 bits (we could also have assumed a
10-bit address)
<ol type="a">
<li>The address is divided into 3 portions:
<ul>
<li>address[1:0] (2 bits) for the byte in the block</li>
<li>address [4:2] (3 bits) for the cache index</li>
<li>address[11:5] (7 bits) for the tag</li>
</ul>
<p>The contents of the cache at the end of each pass are the same. They are
shown below:</p>
<table>
<tr><th>Valid</th><th>Tag</th><th colspan="4">Data (addresses are written inside each byte)</th></tr>
<tr><td>1</td><td>0010 000</td><td>203</td><td>202</td><td>201</td><td>200</td></tr>
<tr><td>1</td><td>0010 000</td><td>207</td><td>206</td><td>205</td><td>204</td></tr>
<tr><td>1</td><td>0010 000</td><td>20B</td><td>20A</td><td>209</td><td>208</td></tr>
<tr><td>1</td><td>0010 010</td><td>24F</td><td>24E</td><td>24D</td><td>24C</td></tr>
<tr><td>1</td><td>0010 111</td><td>2F3</td><td>2F2</td><td>2F1</td><td>2F0</td></tr>
<tr><td>1</td><td>0010 111</td><td>2F7</td><td>2F6</td><td>2F5</td><td>2F4</td></tr>
<tr><td>1</td><td>0010 000</td><td>21B</td><td>21A</td><td>219</td><td>218</td></tr>
<tr><td>1</td><td>0010 000</td><td>21F</td><td>21E</td><td>21D</td><td>21C</td></tr>
</table>

<p>The hit/miss information for each pass is shown below:</p>
<table>
<tr><th>Reference</th><td>200</td><td>204</td><td>208</td><td>20C</td><td>2F4</td><td>2F0</td><td>200</td><td>204</td><td>218</td><td>21C</td><td>24C</td><td>2F4</td></tr>
<tr><th>Pass 1:</th><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>H</td><td>H</td><td>M</td><td>M</td><td>M</td><td>H</td></tr>
<tr><th>Pass 2:</th><td>H</td><td>H</td><td>H</td><td>M</td><td>H</td><td>H</td><td>H</td><td>H</td><td>H</td><td>H</td><td>M</td><td>H</td></tr>
<tr><th>Pass 3:</th><td>H</td><td>H</td><td>H</td><td>M</td><td>H</td><td>H</td><td>H</td><td>H</td><td>H</td><td>H</td><td>M</td><td>H</td></tr>
<tr><th>Pass 4:</th><td>H</td><td>H</td><td>H</td><td>M</td><td>H</td><td>H</td><td>H</td><td>H</td><td>H</td><td>H</td><td>M</td><td>H</td></tr>
</table>
<p>Hit rate is <span class="answer">33/48</span></p>
</li>
<li>
<p>The address is divided into two: 2 bits for identifying
the byte in the block, 10 bits for the tag. No bits are needed for
cache index. The following table shows the contents of the cache at the end of each pass (Valid
bits and Tags are ignored, they should be obvious. Starting addresses
of blocks in the cache are provided):</p>
<table>
<thead>
<tr><th>Pass</th><th>Way 0 Data</th><th>Way 1 Data</th><th>Way 2 Data</th><th>Way 3 Data</th><th>Way 4 Data</th><th>Way 5 Data</th><th>Way 6 Data</th><th>Way 7 Data</th></tr>
</thead>
<tbody>
<tr><td>1</td><td>200</td><td>204</td><td>24C</td><td>20C</td><td>2F4</td><td>2F0</td><td>218</td><td>21C</td></tr>
<tr><td>2</td><td>200</td><td>204</td><td>21C</td><td>24C</td><td>2F4</td><td>20C</td><td>2F0</td><td>218</td></tr>
<tr><td>3</td><td>200</td><td>204</td><td>218</td><td>21C</td><td>2F4</td><td>24C</td><td>20C</td><td>2F0</td></tr>
<tr><td>4</td><td>200</td><td>204</td><td>2F0</td><td>218</td><td>2F4</td><td>21C</td><td>24C</td><td>20C</td></tr>
</tbody>
</table>

<p>The hit/miss information for each pass is shown below:</p>
<table>
<tr><th>Reference:</th><td>200</td><td>204</td><td>208</td><td>20C</td><td>2F4</td><td>2F0</td><td>200</td><td>204</td><td>218</td><td>21C</td><td>24C</td><td>2F4</td></tr>
<tr><th>Pass 1:</th><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>H</td><td>H</td><td>M</td><td>M</td><td>M</td><td>H</td></tr>
<tr><th>Pass 2:</th><td>H</td><td>H</td><td>M</td><td>M</td><td>H</td><td>M</td><td>H</td><td>H</td><td>M</td><td>M</td><td>M</td><td>H</td></tr>
<tr><th>Pass 3:</th><td>H</td><td>H</td><td>M</td><td>M</td><td>H</td><td>M</td><td>H</td><td>H</td><td>M</td><td>M</td><td>M</td><td>H</td></tr>
<tr><th>Pass 4:</th><td>H</td><td>H</td><td>M</td><td>M</td><td>H</td><td>M</td><td>H</td><td>H</td><td>M</td><td>M</td><td>M</td><td>H</td></tr>
</table>
<p>Hit rate is <span class="answer">21/48</span></p>
</li>
<li>
<p>The address is divided into 3 portions: 2 bits for
identifying the byte in the block, 1 bit for the cache index, 9 bits
for the tag. The contents of the cache at the end of Pass 1:</p>

<table>
<thead>
<tr><th colspan="3">Way 0</th><th colspan="3">Way 1</th><th colspan="3">Way 2</th><th colspan="3">Way 3</th></tr>
<tr><th>V</th><th>Tag</th><th>Data</th><th>V</th><th>Tag</th><th>Data</th><th>V</th><th>Tag</th><th>Data</th><th>V</th><th>Tag</th><th>Data</th></tr>
</thead>
<tbody>
<tr><td>1</td><td>0010 0000 0</td><td>203-200</td><td>1</td><td>0010 0000 1</td><td>20B-208</td><td>1</td><td>0010 1111 0</td><td>2F3-2F0</td><td>1</td><td>0010 0001 1</td><td>21B-218</td></tr>
<tr><td>1</td><td>0010 0000 0</td><td>207-204</td><td>1</td><td>0010 0100 1</td><td>24F-24C</td><td>1</td><td>0010 1111 0</td><td>2F7-2F4</td><td>1</td><td>0010 0001 1</td><td>21F-21C</td></tr>
</tbody>
</table>

<p>The hit/miss information for each pass is shown below:</p>

<table>
<tr><th>Reference:</th><td>200</td><td>204</td><td>208</td><td>20C</td><td>2F4</td><td>2F0</td><td>200</td><td>204</td><td>218</td><td>21C</td><td>24C</td><td>2F4</td></tr>
<tr><th>Pass 1:</th><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>H</td><td>H</td><td>M</td><td>M</td><td>M</td><td>H</td></tr>
<tr><th>Pass 2:</th><td>H</td><td>H</td><td>H</td><td>M</td><td>H</td><td>H</td><td>H</td><td>H</td><td>H</td><td>M</td><td>M</td><td>H</td></tr>
<tr><th>Pass 3:</th><td>H</td><td>H</td><td>H</td><td>M</td><td>H</td><td>H</td><td>H</td><td>H</td><td>H</td><td>M</td><td>M</td><td>H</td></tr>
<tr><th>Pass 4:</th><td>H</td><td>H</td><td>H</td><td>M</td><td>H</td><td>H</td><td>H</td><td>H</td><td>H</td><td>M</td><td>M</td><td>H</td></tr>
</table>

<p>Contents of the second set of the cache (index equals 1) after pass 2, 3, and 4 (the first set remains the same):</p>
<table>
<thead>
<tr><th rowspan="2">Pass</th><th colspan="3">Way 0</th><th colspan="3">Way 1</th><th colspan="3">Way 2</th><th colspan="3">Way 3</th></tr>
<tr><th>V</th><th>Tag</th><th>Data</th><th>V</th><th>Tag</th><th>Data</th><th>V</th><th>Tag</th><th>Data</th><th>V</th><th>Tag</th><th>Data</th></tr>
</thead>
<tbody>
<tr><td>2</td><td>1</td><td>0010 0000 0</td><td>207-204</td><td>1</td><td>0010 0001 1</td><td>21F-21C</td><td>1</td><td>0010 1111 0</td><td>2F7-2F4</td><td>1</td><td>0010 0100 1</td><td>24F-24C</td></tr>
<tr><td>3</td><td>1</td><td>0010 0000 0</td><td>207-204</td><td>1</td><td>0010 0100 1</td><td>24F-24C</td><td>1</td><td>0010 1111 0</td><td>2F7-2F4</td><td>1</td><td>0010 0001 1</td><td>21F-21C</td></tr>
<tr><td>4</td><td>1</td><td>0010 0000 0</td><td>207-204</td><td>1</td><td>0010 0001 1</td><td>21F-21C</td><td>1</td><td>0010 1111 0</td><td>2F7-2F4</td><td>1</td><td>0010 0100 1</td><td>24F-24C</td></tr>
</tbody>
</table>

<p>Hit Rate is <span class="answer">30/48</span></p>
</li>
</ol>
</li><!-- End Question -->


<li><!-- Begin Question -->
<h3>Block Size</h3>
<p>The following table lists hit ratios for different cache block sizes given the access sequence 1 (0, 2, 4, 8, 16, 32):</p>
<table>
<thead>
<tr><th>Block Size</th><th>Hit Ratio</th></tr>
</thead>
<tbody>
<tr><td>1B</td><td>0/6</td></tr>
<tr><td>2B</td><td>0/6</td></tr>
<tr><td>4B</td><td>1/6</td></tr>
<tr><td>8B</td><td>2/6</td></tr>
<tr><td>16B</td><td>3/6</td></tr>
<tr><td>32B</td><td>4/6</td></tr>
</tbody>
</table>
<p>Since the hit ratio is reported as 0.33 for this sequence, the block size 
must be <span class="answer">8 bytes</span>. Therefore, the accesses look like this:</p>
<table>
<tr><th>Address</th><td>0</td><td>2</td><td>4</td><td>8</td><td>16</td><td>32</td></tr>
<tr><th>Hit/Miss</th><td>M</td><td>H</td><td>H</td><td>M</td><td>M</td><td>M</td></tr>
</table>
<h3>Associativity</h3>
<p>Notice that all of the addresses of sequence 2 (0, 512, 1024, 1536, 2048, 1536, 1024, 512, 0) are multiples of 512. This means that they all map to the same set, since the size of the cache can only be 256 or 512 bytes. Therefore, the hit ratio would be 0/9 in case of a direct-mapped cache. In case of a 2-way cache, the accesses would behave as follows:</p>
<table>
<tr><th>Address</th><td>0</td><td>512</td><td>1024</td><td>1536</td><td>2048</td><td>1536</td><td>1024</td><td>512</td><td>0</td></tr>
<tr><th>Hit/Miss</th><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>H</td><td>M</td><td>M</td><td>M</td></tr>
</table>
<p>The resulting hit rate would be 1/9. Similarly, for 4-way cache:</p>
<table>
<tr><th>Address</th><td>0</td><td>512</td><td>1024</td><td>1536</td><td>2048</td><td>1536</td><td>1024</td><td>512</td><td>0</td></tr>
<tr><th>Hit/Miss</th><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>H</td><td>H</td><td>H</td><td>M</td></tr>
</table>
<p>The resulting hit rate would be 3/9, and thus the cache is <span class="answer">4-way set associative</span>.</p>
<h3>Cache Size</h3>
<p>If the cache size were 256B, there would be 3 index bits and all of the adresses in sequence 3 (0, 64, 128, 256, 512, 256, 128, 64, 0) would map to the same set:</p>
<table>
<tr><th>Address</th><td>0</td><td>64</td><td>128</td><td>256</td><td>512</td><td>256</td><td>128</td><td>64</td><td>0</td></tr>
<tr><th>Hit/Miss</th><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>H</td><td>H</td><td>H</td><td>M</td></tr>
</table>
<p>The resulting hit ratio would be 3/9, and thus the cache size is <span class="answer">256B</span>.
For completeness, here's how the accesses would look like in case of a 512B cache (4 index bits):</p>
<table>
<tr><th>Address</th><td>0</td><td>64</td><td>128</td><td>256</td><td>512</td><td>256</td><td>128</td><td>64</td><td>0</td></tr>
<tr><th>Hit/Miss</th><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>H</td><td>H</td><td>H</td><td>H</td></tr>
</table>
<h3>Replacement Policy</h3>
<p>In case of the FIFO replacement policy, the accesses of sequence 3 (0, 512, 1024, 0, 1536, 0, 2048, 512) would look as follows:</p>
<table>
<tr><th>Address</th><td>0</td><td>512</td><td>1024</td><td>0</td><td>1536</td><td>0</td><td>2048</td><td>512</td></tr>
<tr><th>Hit/Miss</th><td>M</td><td>M</td><td>M</td><td>H</td><td>M</td><td>H</td><td>M</td><td>H</td></tr>
</table>
<p>The resulting hit ration would be 3/8. However, in case of the LRU replacement policy the hit rate would be 0.25:</p>
<table>
<tr><td>0</td><td>512</td><td>1024</td><td>0</td><td>1536</td><td>0</td><td>2048</td><td>512</td></tr>
<tr><td>M</td><td>M</td><td>M</td><td>H</td><td>M</td><td>H</td><td>M</td><td>M</td></tr>
</table>
<p>Thus the replacement policy is <span class="answer">LRU</span>.</p>

</li><!-- End Question -->

</ol>
</body>
</html>


