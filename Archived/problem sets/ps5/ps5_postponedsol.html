<li><!-- Begin Question -->
<p>Assume an ADD operation is executed like this in the pipeline:</p>
<table class="pipeline">
<tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr>
<tr><td>F</td><td>D</td><td>A</td><td>A</td><td>A</td><td>A</td><td>S</td></tr>
</table>
<p>and a MUL operation is executed like this in the pipeline:</p>
<table class="pipeline">
<tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr>
<tr><td>F</td><td>D</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>S</td></tr>
</table>
<p>
F: Fetch, D: Decode, A: Execute stage (for ADD), M: Execute stage for MUL, S: Store result (Write-back)</p>
<ol>
<li>ADDs require 7 cycles (fetch, decode, 4 execute, store), and MULs require 9 cycles (fetch, decode, 6 execute, store). For
 3 ADD instructions and 3 MUL instructions, the execution time is <span class="equation">3 &times; 7 + 3 &times; 9 = <span class="answer">48</span></span> cycles.</li>
<li>Pipeline with scoreboarding and five adders and five multipliers (assuming one instruction fetched per cycle):
<ol>
<li>No data forwarding: the destination register is marked valid in the S stage
(a dependent instruction starts executing after the S stage of the instruction it depends on)
<table class="pipeline">
<thead>
<tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th><th>17</th><th>18</th><th>19</th><th>20</th><th>21</th><th>22</th><th>23</th><th>24</th><th>25</th><th>26</th></tr>
</thead>
<tbody>
<tr><td>F</td><td>D</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td>F</td><td>D</td><td>D</td><td>D</td><td>D</td><td>D</td><td>D</td><td>D</td><td>A</td><td>A</td><td>A</td><td>A</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>D</td><td>A</td><td>A</td><td>A</td><td>A</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>F</td><td>D</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>F</td><td>D</td><td>D</td><td>D</td><td>D</td><td>D</td><td>D</td><td>D</td><td>A</td><td>A</td><td>A</td><td>A</td><td>S</td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>D</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>S</td></tr>
</tbody>
</table>
<p>Execution time: <span class="answer">26 cycles</span></p>
</li>
<li>With forwarding:
<table class="pipeline">
<thead>
<tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th><th>17</th><th>18</th><th>19</th><th>20</th><th>21</th><th>22</th><th>23</th><th>24</th></tr>
</thead>
<tbody>
<tr><td>F</td><td>D</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td>F</td><td>D</td><td>D</td><td>D</td><td>D</td><td>D</td><td>D</td><td>A</td><td>A</td><td>A</td><td>A</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>D</td><td>A</td><td>A</td><td>A</td><td>A</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>F</td><td>D</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>F</td><td>D</td><td>D</td><td>D</td><td>D</td><td>D</td><td>D</td><td>A</td><td>A</td><td>A</td><td>A</td><td>S</td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>D</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>S</td></tr>
</tbody>
</table>
<p>Execution time: <span class="answer">24 cycles</span></p>
</li>
</ol>
</li>
<li>
<p>Pipeline with scoreboarding and one adder and one multiplier (assuming one instruction fetched per cycle):</p>
<ol>
<li>
<p>The adder and multiplier are not pipelined and there is no data forwarding:</p>
<table class="pipeline">
<thead>
<tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th><th>17</th><th>18</th><th>19</th><th>20</th><th>21</th><th>22</th><th>23</th><th>24</th><th>25</th><th>26</th><th>27</th><th>28</th><th>29</th></tr>
</thead>
<tbody>
<tr><td>F</td><td>D</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td>F</td><td>D</td><td>D</td><td>D</td><td>D</td><td>D</td><td>D</td><td>D</td><td>A</td><td>A</td><td>A</td><td>A</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>D</td><td>D</td><td>D</td><td>D</td><td>A</td><td>A</td><td>A</td><td>A</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>F</td><td>F</td><td>F</td><td>F</td><td>D</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>F</td><td>D</td><td>D</td><td>D</td><td>D</td><td>D</td><td>D</td><td>D</td><td>A</td><td>A</td><td>A</td><td>A</td><td>S</td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>D</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>S</td></tr>
</tbody>
</table>
<p>Execution time: <span class="answer">29 cycles</span></p>
</li>
<li>
<p>The adder and multiplier are not pipelined and there is data forwarding:</p>
<table class="pipeline">
<thead>
<tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th><th>17</th><th>18</th><th>19</th><th>20</th><th>21</th><th>22</th><th>23</th><th>24</th><th>25</th><th>26</th><th>27</th></tr>
</thead>
<tbody>
<tr><td>F</td><td>D</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td>F</td><td>D</td><td>D</td><td>D</td><td>D</td><td>D</td><td>D</td><td>A</td><td>A</td><td>A</td><td>A</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>D</td><td>D</td><td>D</td><td>D</td><td>A</td><td>A</td><td>A</td><td>A</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>F</td><td>F</td><td>F</td><td>D</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>F</td><td>D</td><td>D</td><td>D</td><td>D</td><td>D</td><td>D</td><td>A</td><td>A</td><td>A</td><td>A</td><td>S</td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>D</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>S</td></tr>
</tbody>
</table>
<p>Execution time: <span class="answer">27 cycles</span></p>
</li>
<li>
<p>The adder and multiplier are pipelined and there is no data forwarding:</p>
<table class="pipeline">
<thead>
<tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th><th>17</th><th>18</th><th>19</th><th>20</th><th>21</th><th>22</th><th>23</th><th>24</th><th>25</th><th>26</th></tr>
</thead>
<tbody>
<tr><td>F</td><td>D</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td>F</td><td>D</td><td>D</td><td>D</td><td>D</td><td>D</td><td>D</td><td>D</td><td>A</td><td>A</td><td>A</td><td>A</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>D</td><td>A</td><td>A</td><td>A</td><td>A</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>F</td><td>D</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>F</td><td>D</td><td>D</td><td>D</td><td>D</td><td>D</td><td>D</td><td>D</td><td>A</td><td>A</td><td>A</td><td>A</td><td>S</td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>D</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>S</td></tr>
</tbody>
</table>
<p>Execution time: <span class="answer">26 cycles</span></p>
</li>
<li>
<p>The adder and multiplier are pipelined and there is data forwarding:</p>
<table class="pipeline">
<thead>
<tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th><th>17</th><th>18</th><th>19</th><th>20</th><th>21</th><th>22</th><th>23</th><th>24</th></tr>
</thead>
<tbody>
<tr><td>F</td><td>D</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td>F</td><td>D</td><td>D</td><td>D</td><td>D</td><td>D</td><td>D</td><td>A</td><td>A</td><td>A</td><td>A</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>D</td><td>A</td><td>A</td><td>A</td><td>A</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>F</td><td>D</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>F</td><td>D</td><td>D</td><td>D</td><td>D</td><td>D</td><td>D</td><td>A</td><td>A</td><td>A</td><td>A</td><td>S</td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>D</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>M</td><td>S</td></tr>
</tbody>
</table>
<p>Execution time: <span class="answer">24 cycles</span></p>
</li>
</ol>
</li>
</ol>
</li><!-- End of Question -->


<!-- Begin Question -->
<li>Assumptions:
<ul>
<li>There are enough ports to the register file.</li>

<li>There are enough ports to the memory.</li>

<li>There are separate execution units for ADD, AND, STW, and BR
instructions (They can all be in the execute stage at the same time.)</li>
</ul>
<ol>
<li><p>Pipeline diagram:</p>
<table class="pipeline">
<thead>
<tr><th>Instruction</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr>
</thead>
<tbody>
<tr><td colspan="16" class="comment">Start of first iteration (R1 is even)</td></tr>
<tr><td class="instr">STW</td><td>F</td><td>D</td><td>E</td><td>E</td><td>E</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td class="instr">ADD</td><td></td><td>F</td><td>D</td><td>E</td><td>E</td><td>E</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td class="instr">AND</td><td></td><td></td><td>F</td><td>D</td><td>E</td><td>E</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td class="instr">BRz</td><td></td><td></td><td></td><td>F</td><td>D</td><td>D</td><td>E</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td class="instr">ADD</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>F</td><td>D</td><td>E</td><td>E</td><td>E</td><td>S</td><td></td><td></td></tr>
<tr><td class="instr">ADD</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>F</td><td>D</td><td>E</td><td>E</td><td>E</td><td>S</td><td></td></tr>
<tr><td class="instr">BRp</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>F</td><td>D</td><td>D</td><td>D</td><td>E</td><td>S</td></tr>
<tr><td colspan="16" class="comment">End of the first iteration (R1 is odd now)</td></tr>
<tr><td class="instr">STW</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>F</td></tr>
</tbody>
</table>
<p>
The loop takes the same number of cycles to execute for even and odd values of R1. Each iteration takes 14 cycles
in the steady state. There are 5 iterations for even values of R1 and 4 iterations for odd values of
R1. The total number of cycles is:</p>
<div class="equation">
(14 &times; 5) + (14 &times; 4) + 1 = <span class="answer">127</span>
</div>
<p>The extra 1 cycle comes from the last iteration (Store result stage of the BRp instruction).</p>
</li>
<li><p>Pipeline diagram:</p>
<table class="pipeline">
<thead>
<tr><th>Instruction</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th></tr>
</thead>
<tbody>
<tr><td colspan="17" class="comment">Start of first iteration (R1 is even)</td></tr>
<tr><td class="instr">STW</td><td>F</td><td>D</td><td>E</td><td>E</td><td>E</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td class="instr">ADD</td><td></td><td>F</td><td>D</td><td>E</td><td>E</td><td>E</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td class="instr">AND</td><td></td><td></td><td>F</td><td>D</td><td>E</td><td>E</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td class="instr">BRz</td><td></td><td></td><td></td><td>F</td><td>D</td><td>D</td><td>E</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td class="instr">ADD</td><td></td><td></td><td></td><td></td><td>F</td><td>F</td><td>D</td><td>E</td><td>E</td><td>E</td><td>S</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td class="instr">ADD</td><td></td><td></td><td></td><td></td><td></td><td></td><td>F</td><td>D</td><td>E</td><td>E</td><td>E</td><td>S</td><td></td><td></td><td></td><td></td></tr>
<tr><td class="instr">BRp</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>F</td><td>D</td><td>D</td><td>D</td><td>E</td><td>S</td><td></td><td></td><td></td></tr>
<tr><td colspan="17" class="comment">End of the first iteration (R1 is odd now)</td></tr>
<tr><td class="instr">STW</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>F</td><td>F</td><td>F</td><td>D</td><td>E</td><td>E</td><td>E</td><td>S</td></tr>
</tbody>
</table>
<p>The loop takes the same number of cycles to execute for even and odd values of R1. Each iteration takes 13 cycles
but 3 cycles can be overlapped with the next iteration. 
The total number of cycles is:</p>
<div class="equation">
	(10 &times; 9) + 3 = <span class="answer">93</span>
</div>

</li>

<li><p>BRz instruction will always be predicted not taken. It is taken
when R1 is even. So it will be mispredicted when R1 is even and
correctly predicted when R1 is odd. The following diagram shows three
consecutive iterations of the loop. In the first iteration, BRz is
mispredicted, in the second iteration it is correctly predicted.</p>
<p>The first BRp instruction is always predicted taken. It is always
predicted correctly. The second BRp instruction is also always
predicted taken. It is mispredicted only once in the last iteration of
the loop.</p>

<pre style="font-size: smaller">
        1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33    
-------------------------------------------------------------------------------------------------------------- Start of first iteration (R1 is even)
STW     F | D | E | E | E | S
ADD         F | D | E | E | E | S
AND             F | D | E | E | S
BRz                 F | D | D | E | S  (Mispredicted)
ADD R1, R1, #3          F | F | D | Flushed
ADD R5, R5, #-1                 F | Flushed
ADD R1, R1, #1                      F | D | E | E | E | S
ADD R7, R7, #-1                         F | D | E | E | E | S
BRp DOIT                                    F | D | D | D | E | S (Correctly predicted)
------------------------------------------------------------------------------------------------------------- Start of second iteration (R1 is odd)
STW                                             F | F | F | D | E | E | E | S
ADD                                                         F | D | E | E | E | S
AND                                                             F | D | E | E | S
BRz                                                                 F | D | D | E | S (Correctly predicted)
ADD R1, R1, #3                                                          F | F | D | E | E | E | S
ADD R5, R5, #-1                                                                 F | D | E | E | E | S
BRp DOIT                                                                            F | D | D | D | E | S (Correctly predicted)
------------------------------------------------------------------------------------------------------------ Third iteration (R1 is even)
STW                                                                                     F | F | F | D | E | E | S 
ADD                                                                                                 F | D | E | E | E | S
AND                                                                                                     F | D | E | E | S
BRz                                                                                                         F | D | D | E | S  (Mispredicted)
ADD R1, R1, #3                                                                                                  F | F | D | Flushed
ADD R5, R5, #-1                                                                                                         F | Flushed
ADD R1, R1, #1                                                                                                              F | D | E | E | E | S
ADD R7, R7, #-1                                                                                                                 F | D | E | E | E | S
BRp DOIT                                                                                                                            F | D | D | D | E | S (Correctly predicted)
        &lt;--------- beginning of the loop ----&gt;&lt;------------------------ steady state (22 cycles) ------------------------------------&gt;
</pre>

<p>Loop steady state is shown above. It takes 22 cycles and it is
repeated 4 times. The beginning of the loop (until the steady state)
takes 10 cycles as shown above. The end of the loop (part of the last
iteration which is not in steady state) takes 5 more cycles to
execute. The total number of cycles is:</p>
<div class="equation">
	10 + (4 &times; 22) + 5 = <span class="answer">103</span>
</div>

<p>Prediction accuracies for each branch are:</p>

<ul>
<li>BRz  = 4/9 (Correctly predicted when R1 is odd, R1 is odd for 4 iterations of the loop)</li>
<li>first BRp  = 4/4</li>
<li>second BRp = 4/5 (Mispredicted only in the last iteration - Note
that this misprediction does not affect the number of cycles it takes
to execute the loop)</li>
</ul>
<p>Combined branch prediction accuracy = 12/18 = <span class="answer">67%</span></p>
</li>
</ol>
</li><!-- End of Question -->

<li><!-- Begin Question -->
<ol>
<li><br /><img src="code.jpg" alt="Filled out instruction sequence" /></li>

<li><br /><img src="tomasulo_sol.jpg" alt="Filled out reservation stations" /></li>

<li><br /><img src="RAT.jpg" alt="Filled out register alias table" /></li>
</ol>
</li><!-- End of Question -->

<li><!-- Begin Question -->
<p>Assume the destination register is indicated first, followed by the source(s).</p>
<p>
(As stated in the question, cycle counts assume a 16-way interleaved memory so that a new access can
be started each cycle.  Also, the adder and multiplier are pipelined.)</p>
<ol>
<li>
<p>Scalar processor (one of the possible solutions)</p>
<pre>
        MOVI   R0, 0            (1 cycle)
        LEA    R4, A            (1 cycle)
        LEA    R5, B            (1 cycle)
        LEA    R6, C            (1 cycle)
        LEA    R7, D            (1 cycle)
  LOOP  LD     R1, R5, R0       (11 cycles)
        LD     R2, R6, R0       (11 cycles)
        LD     R3, R7, R0       (11 cycles)
        MUL    R1, R1, R2       (6 cycles)
        ADD    R1, R1, R3       (4 cycles)
        RSHFA  R1, R1, 1        (1 cycle)
        ST     R1, R4, R0       (11 cycles)
        ADD    R0, R0, 1        (4 cycles)
        ADD    R1, R0, -100     (4 cycles)
        BNZ    LOOP             (1 cycle)
</pre>
<div class="equation">
        5 &times; 1 + 100 &times; (11 + 11 + 11 + 6 + 4 + 1 + 11 + 4 + 4 + 1) = <span class="answer">6405 cycles</span>
</div>
</li>
<li><p>Vector Processor:</p>
<p>
The loop could be split into two parts as 64 and 36.
Assume the vector code looks as follows:
(This solution assumes that the addressing mode VLD V0, B+64 exists - if it doesn't,
then you would need 4 + 3 cycles using a pipelined adder to add 64 to A,B,C,D)</p>
<pre>
        LD     Vln, #64           (1 cycle)
        LD     Vst, #1            (1 cycle)
        VLD    V0, B              (11 + 63 cycles)
        VLD    V1, C              (11 + 63 cycles)
        Vmul   V2, V0, V1         (6 + 63 cycles)
        VLD    V3, D              (11 + 63 cycles)
        Vadd   V4, V2, V3         (4 + 63 cycles)
        Vrshfa V5, V4, 1          (1 + 63 cycles)
        VST    V5, A              (11 + 63 cycles)
        LD     Vln, #36           (1 cycle)
        VLD    V0, B+64           (11 + 35 cycles)
        VLD    V1, C+64           (11 + 35 cycles)
        Vmul   V2, V0, V1         (6 + 35 cycles)
        VLD    V3, D+64           (11 + 35 cycles)
        Vadd   V4, V2, V3         (4 + 35 cycles)
        Vrshfa V5, V4, 1          (1 + 35 cycles)
        VST    V5, A+64           (11 + 35 cycles)
</pre>

<ol>
<li>
<p>Vector processor without chaining (vector instructions done serially)</p>
<p>First part:</p>
<pre>
|-1-|-1-|--11--|---63---|--11--|---63---|-6-|---63---|--11--|---63---|-4-|---63---|-1-|---63---|--11--|---63---|
</pre>
<p>Second part:</p>
<pre>
|-1-|--11--|--35--|--11--|--35--|-6-|--35--|--11--|--35--|-4-|--35--|-1-|--35--|--11--|--35--|
</pre>
<div class="equation">
        2 + (74 &times; 4 + 69 + 67 + 64) + 1 + (46 &times; 4 + 41 + 39 + 36) = <span class="answer">799 cycles</span>
</div>
</li>
<li>
<p>Vector processor with chaining, 1 port to memory.</p>
<p>Chaining means the machine begins the next operation as soon as
the operands are ready.</p>
<p>First part:</p>
<pre>
 |-1-|-1-|--11--|---63---|--11--|---63---|--11--|---63---|--11--|---63---|
                                |-6-|---63---|  |-4-|---63---|
                                                    |-1-|---63---|
</pre>
<p>Second part:</p>
<pre>
 |-1-|--11--|--35--|--11--|--35--|--11--|--35--|--11--|--35--|
                          |-6-|--35--|  |-4-|--35--|
                                            |-1-|--35--|
</pre>
<p>Chaining, in this instance, hides the VMULT, VADD, and VSHL operations.
Memory becomes the primary bottleneck.</p>
<span class="answer">483 cycles</span>
</li>
<li>
<p>Vector processor with chaining; 2 loads, 1 store per cycle.</p>
<p>First part:</p>
<pre>
 |-1-|-1-|--11--|---63---|
          |--11--|---63---|
                 |-6-|---63---|
                         |--11--|---63---|
                                |-4-|---63---|
                                    |-1-|---63---|
                                        |--11--|---63---|
</pre>
<div class="equation">
 #cycles = 1 + 1 + 11 + 63 + 11 + 4 + 1 + 11 + 63 = 166
</div>
<p>Second part:</p>
<pre>
 |-1-|--11--|--35--|
      |--11--|--35--|
             |-6-|--35--|
                   |--11--|--35--|
                          |-4-|--35--|
                              |-1-|--35--|
                                  |--11--|--35--|
</pre>
<div class="equation">
 #cycles = 1 + 11 + 35 + 11 + 4 + 1 + 11 + 35 = 109
</div>
 Total cycles = 166 + 109 = <span class="answer">275 cycles</span>
</li>
</ol>
<p>Another solution is to split the loop into two equal parts as 50 and 50.</p>
<pre>
        LD     Vln, #50           (1 cycle)
        LD     Vst, #1            (1 cycle)
        VLD    V0, B              (11 + 49 cycles)
        VLD    V1, C              (11 + 49 cycles)
        Vmul   V2, V0, V1         (6 + 49 cycles)
        VLD    V3, D              (11 + 49 cycles)
        Vadd   V4, V2, V3         (4 + 49 cycles)
        Vrshfa V5, V4, 1          (1 + 49 cycles)
        VST    V5, A              (11 + 49 cycles)
        VLD    V0, B+50           (11 + 49 cycles)
        VLD    V1, C+50           (11 + 49 cycles)
        Vmul   V2, V0, V1         (6 + 49 cycles)
        VLD    V3, D+50           (11 + 49 cycles)
        Vadd   V4, V2, V3         (4 + 49 cycles)
        Vrshfa V5, V4, 1          (1 + 49 cycles)
        VST    V5, A+50           (11 + 49 cycles)
</pre>
<ol>
<li>
<p>Vector processor without chaining (vector instructions done serially)</p>
<p>First part:</p>
<pre>
 |-1-|-1-|--11--|---63---|--11--|---63---|-6-|---63---|--11--|---63---|-4-|---63---|-1-|---63---|--11--|---63---|
</pre>
<p>Second part:</p>
<pre>
 |--11--|--35--|--11--|--35--|-6-|--35--|--11--|--35--|-4-|--35--|-1-|--35--|--11--|--35--|
</pre>
<div class="equation">
 2 + (74 &times; 4 + 69 + 67 + 64) + (46 &times; 4 + 41 + 39 + 36) = <span class="answer">798 cycles</span>
</div>
</li>
<li>
<p>Vector processor with chaining, 1 port to memory.
Again, this would save only 1 cycle over solution A, since the first load for the second part must wait till the store of the first part 
finishes. Total = <span class="answer">482 cycles</span></p>
</li>
<li>
<p>Vector processor with chaining; 2 loads, 1 store per cycle</p>
<pre>
 |-1-|-1-|-11-|-----49-----|
          |-11-|-----49-----|
               |-6-|-----49-----|
                           |-11-|-----49-----|   ** LD D would need to wait for LD B to finish
                                |-4-|-----49-----|
                                    |-1-|-----49-----|
                                        |-11-|-----49-----|
                                         |-11-|-----49-----|
                                             |-11-|-----49-----|  ** LD C+50 would need to wait till the LD D from the first part finishes
                                                  |-6-|-----49-----|
                                                           |-11-|-----49-----|  ** LD D+50 would need to wait for LD B+50 to finish 
                                                                |-4-|-----49-----|
                                                                    |-1-|-----49-----|

                                                                        |-11-|-----49-----|
</pre>
<div class="equation">
 1 + 1 + (11 + 49) + 11 + 4 + 1 + 1 + (11 + 49) + 11 + 4 + 1 + (11 + 49) = <span class="answer">215 cycles</span>
</div>
</li>
</ol>
</li>
</ol>
</li><!-- End of Question -->

<li><!-- Begin Question -->
<ol>
<li>
<p>X is the Vector Index Register, which holds the pointer to the element that is being processed by the vector instruction.</p>
</li>
<li>
<p>The two control signals are RESET.VINDEX and INCREMENT.VINDEX</p>
</li>
<li>
<br />
<img src="greybox_sol.jpg" width="541" height="489" alt="Logic diagram of the grey box" />
</li>
<li>
<p>The following solution assumes a change to the microsequencer to branch according to the Z condition code.</p>
<img src="states_vld_ps5.jpg" width="644" height="854" alt="Modified state diagram" />
</li>
</ol>
</li><!-- End of Question -->
