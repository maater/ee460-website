<html>
<head>
<title> EE 360N - Problem Set 5 Solutions</title>
</head>
<body bgcolor=white text=black>

<center>
<h3>
Department of Electrical and Computer Engineering
</h3>
<h4>
The University of Texas at Austin
</h4>
</center>

EE 360N, Fall 2005 <br>
Problem Set 5 Solutions <br>

Yale N. Patt, Instructor
<br>
Chang Joo Lee, Rustam Miftakhutdinov, Poorna Samanta, TAs<br>

<p>
<ol>

<li><!-- Begin Question -->

<ol TYPE="a">
<li>The address is divided into 3 portions:
<ul>
<li>address[3:0] (4 bits) for the byte in the block</li>
<li>address[5:4] (2 bits) for the cache index</li>
<li>address[15:6] (10 bits) for the tag</li>
</ul>

<p>The hit/miss information for each pass is shown below:
<table BORDER >
<tr>
<td>Reference:</td>
<td>x3210</td>
<td>x3212</td>
<td>x3318</td>
<td>x3394</td>
<td>x3214</td>
<td>x3040</td>
<td>x3218</td>
<td>x3394</td>
<td>x3310</td>
<td>x3390</td>
</tr>
<tr>
<td>Pass 1:</td>
<td>M</td>
<td>H</td>
<td>M</td>
<td>M</td>
<td>M</td>
<td>M</td>
<td>H</td>
<td>M</td>
<td>M</td>
<td>M</td>
</tr>
<tr>
<td>Pass 2:</td>
<td>M</td>
<td>H</td>
<td>M</td>
<td>M</td>
<td>M</td>
<td>H</td>
<td>H</td>
<td>M</td>
<td>M</td>
<td>M</td>
</tr>
<tr>
<td>Pass 3:</td>
<td>M</td>
<td>H</td>
<td>M</td>
<td>M</td>
<td>M</td>
<td>H</td>
<td>H</td>
<td>M</td>
<td>M</td>
<td>M</td>
</tr>
<tr>
</table>
<p>Hit rate = 8/30
</li>
<li>The address is divided into 3 portions:
<ul>
<li>address[3:0] (4 bits) for the byte in the block</li>
<li>address[4] (1 bit) for the cache index</li>
<li>address[15:5] (11 bits) for the tag</li>
</ul>
<p>The hit/miss information for each pass is shown below:
<table BORDER >
<tr>
<td>Reference:</td>
<td>x3210</td>
<td>x3212</td>
<td>x3318</td>
<td>x3394</td>
<td>x3214</td>
<td>x3040</td>
<td>x3218</td>
<td>x3394</td>
<td>x3310</td>
<td>x3390</td>
</tr>
<tr>
<td>Pass 1:</td>
<td>M</td>
<td>H</td>
<td>M</td>
<td>M</td>
<td>M</td>
<td>M</td>
<td>H</td>
<td>H</td>
<td>M</td>
<td>H</td>
</tr>
<tr>
<td>Pass 2:</td>
<td>M</td>
<td>H</td>
<td>M</td>
<td>M</td>
<td>M</td>
<td>H</td>
<td>H</td>
<td>H</td>
<td>M</td>
<td>H</td>
</tr>
<tr>
<td>Pass 3:</td>
<td>M</td>
<td>H</td>
<td>M</td>
<td>M</td>
<td>M</td>
<td>H</td>
<td>H</td>
<td>H</td>
<td>M</td>
<td>H</td>
</tr>
</table>
<p>Hit rate = 14/30
</li>
<li>The address is divided into 2 portions:
<ul>
<li>address[3:0] (4 bits) for the byte in the block</li>
<li>address[15:4] (11 bits) for the tag</li>
</ul>
<p>The hit/miss information for each pass is shown below:
<table BORDER >
<tr>
<td>Reference:</td>
<td>x3210</td>
<td>x3212</td>
<td>x3318</td>
<td>x3394</td>
<td>x3214</td>
<td>x3040</td>
<td>x3218</td>
<td>x3394</td>
<td>x3310</td>
<td>x3390</td>
</tr>
<tr>
<td>Pass 1:</td>
<td>M</td>
<td>H</td>
<td>M</td>
<td>M</td>
<td>H</td>
<td>M</td>
<td>H</td>
<td>H</td>
<td>H</td>
<td>H</td>
</tr>
<tr>
<td>Pass 2:</td>
<td>H</td>
<td>H</td>
<td>H</td>
<td>H</td>
<td>H</td>
<td>H</td>
<td>H</td>
<td>H</td>
<td>H</td>
<td>H</td>
</tr>
<tr>
<td>Pass 3:</td>
<td>H</td>
<td>H</td>
<td>H</td>
<td>H</td>
<td>H</td>
<td>H</td>
<td>H</td>
<td>H</td>
<td>H</td>
<td>H</td>
</tr>
</table>
<p>Hit rate = 26/30
</li>
</ol>
</li><!-- End of Question -->



<li> Assume the destination register is indicated first, followed by the source(s).
<p>
(As stated in the question, cycle counts assume a 16-way interleaved memory so that a new access can
be started each cycle.  Also, the adder and multiplier are pipelined.)
<p>
a) Scalar processor (one of the possible solutions)
<br>
<pre>
        MOVI   R0, 0            (1 cycle)
        LEA    R4, A            (1 cycle)
        LEA    R5, B            (1 cycle)
        LEA    R6, C            (1 cycle)
        LEA    R7, D            (1 cycle)
  LOOP  LD     R1, R5, R0       (11 cycles)
        LD     R2, R6, R0       (11 cycles)
        LD     R3, R7, R0       (11 cycles)
        MUL    R1, R1, R2       (6 cycles)
        ADD    R1, R1, R3       (4 cycles)
        RSHFA  R1, R1, 1        (1 cycle)
        ST     R1, R4, R0       (11 cycles)
        ADD    R0, R0, 1        (4 cycles)
        ADD    R1, R0, -100     (4 cycles)
        BNZ    LOOP             (1 cycle)

        5*1 + 100*(11 + 11 + 11 + 6 + 4 + 1 + 11 + 4 + 4 + 1) = 6405 cycles
</pre>
<br>
b) Vector Processor:
<p>
Solution A: The loop could be split into two parts as 64 and 36.
Assume the vector code looks as follows:
(This solution assumes that the addressing mode VLD V0, B+64 exists - if it doesn't,
then you would need 4 + 3 cycles using a pipelined adder to add 64 to A,B,C,D)
<pre>
        LD     Vln, #64           (1 cycle)
        LD     Vst, #1            (1 cycle)
        VLD    V0, B              (11 + 63 cycles)
        VLD    V1, C              (11 + 63 cycles)
        Vmul   V2, V0, V1         (6 + 63 cycles)
        VLD    V3, D              (11 + 63 cycles)
        Vadd   V4, V2, V3         (4 + 63 cycles)
        Vrshfa V5, V4, 1          (1 + 63 cycles)
        VST    V5, A              (11 + 63 cycles)
        LD     Vln, #36           (1 cycle)
        VLD    V0, B+64           (11 + 35 cycles)
        VLD    V1, C+64           (11 + 35 cycles)
        Vmul   V2, V0, V1         (6 + 35 cycles)
        VLD    V3, D+64           (11 + 35 cycles)
        Vadd   V4, V2, V3         (4 + 35 cycles)
        Vrshfa V5, V4, 1          (1 + 35 cycles)
        VST    V5, A+64           (11 + 35 cycles)
</pre>
<br>

i. Vector processor without chaining (vector instructions done serially)
<pre>
   First part:
   |-1-|-1-|--11--|---63---|--11--|---63---|-6-|---63---|--11--|---63---|-4-|---63---|-1-|---63---|--11--|---63---|

   Second part:
   |-1-|--11--|--35--|--11--|--35--|-6-|--35--|--11--|--35--|-4-|--35--|-1-|--35--|--11--|--35--|

        2 + (74*4 +69+67+64) + 1 + (46*4 +41+39+36) = 799 cycles
</pre>
<br>

ii. Vector processor with chaining, 1 port to memory
<pre>
   Chaining means the machine begins the next operation as soon as
   the operands are ready.

   First part:
   |-1-|-1-|--11--|---63---|--11--|---63---|--11--|---63---|--11--|---63---|
                                  |-6-|---63---|  |-4-|---63---|
                                                      |-1-|---63---|
   Second part:
   |-1-|--11--|--35--|--11--|--35--|--11--|--35--|--11--|--35--|
                            |-6-|--35--|  |-4-|--35--|
                                              |-1-|--35--|

   Chaining, in this instance, hides the VMULT, VADD, and VSHL operations.
   Memory becomes the primary bottleneck.

        483 cycles
</pre>
<br>
iii. Vector processor with chaining; 2 loads, 1 store per cycle
<pre>

   First part:
   |-1-|-1-|--11--|---63---|
            |--11--|---63---|
                   |-6-|---63---|
                           |--11--|---63---|
                                  |-4-|---63---|
                                      |-1-|---63---|
                                          |--11--|---63---|

   #cycles = 1 + 1 + 11 + 63 + 11 + 4 + 1 + 11 + 63 = 166


   Second part:
   |-1-|--11--|--35--|
        |--11--|--35--|
               |-6-|--35--|
                     |--11--|--35--|
                            |-4-|--35--|
                                |-1-|--35--|
                                    |--11--|--35--|

   #cycles = 1 + 11 + 35 + 11 + 4 + 1 + 11 + 35 = 109

   Total cycles = 166 + 109 = 275 cycles
</pre>
<br>
Solution B: The loop could be split into two equal parts as 50 and 50.
<pre>
        LD     Vln, #50           (1 cycle)
        LD     Vst, #1            (1 cycle)
        VLD    V0, B              (11 + 49 cycles)
        VLD    V1, C              (11 + 49 cycles)
        Vmul   V2, V0, V1         (6 + 49 cycles)
        VLD    V3, D              (11 + 49 cycles)
        Vadd   V4, V2, V3         (4 + 49 cycles)
        Vrshfa V5, V4, 1          (1 + 49 cycles)
        VST    V5, A              (11 + 49 cycles)
        VLD    V0, B+50           (11 + 49 cycles)
        VLD    V1, C+50           (11 + 49 cycles)
        Vmul   V2, V0, V1         (6 + 49 cycles)
        VLD    V3, D+50           (11 + 49 cycles)
        Vadd   V4, V2, V3         (4 + 49 cycles)
        Vrshfa V5, V4, 1          (1 + 49 cycles)
        VST    V5, A+50           (11 + 49 cycles)
</pre>
<br>

i. Vector processor without chaining (vector instructions done serially)
<pre>
   First part:
   |-1-|-1-|--11--|---63---|--11--|---63---|-6-|---63---|--11--|---63---|-4-|---63---|-1-|---63---|--11--|---63---|

   Second part:
   |--11--|--35--|--11--|--35--|-6-|--35--|--11--|--35--|-4-|--35--|-1-|--35--|--11--|--35--|

        2 + (74*4 +69+67+64) + (46*4 +41+39+36) = 798 cycles
</pre>
<br>
ii. Vector processor with chaining, 1 port to memory
   Again, this would save only 1 cycle over solution A, since the first load for the second part must wait till the store of the first part 
finishes. Total = 482 cycles.
<br>   
iii. Vector processor with chaining; 2 loads, 1 store per cycle
<pre>
   |-1-|-1-|-11-|-----49-----|
            |-11-|-----49-----|
                 |-6-|-----49-----|
                             |-11-|-----49-----|   ** LD D would need to wait for LD B to finish
                                  |-4-|-----49-----|
                                      |-1-|-----49-----|
                                          |-11-|-----49-----|
                                           |-11-|-----49-----|
                                               |-11-|-----49-----|  ** LD C+50 would need to wait till the LD D from the first part finishes
                                                    |-6-|-----49-----|
                                                             |-11-|-----49-----|  ** LD D+50 would need to wait for LD B+50 to finish 
                                                                  |-4-|-----49-----|
                                                                      |-1-|-----49-----|

                                                                          |-11-|-----49-----|
</pre>
<pre>
   1 + 1 + (11 + 49) + 11 + 4 + 1 + 1 + (11 + 49) + 11 + 4 + 1 + (11 + 49) = 215 cycles

</pre>

</li>

<li>
a) X is the Vector Index Register, which holds the pointer to the element that is being processed by the vector instruction.
<p>

b) The two control signals are RESET.VINDEX and INCREMENT.VINDEX
<p>

c)
<p> 
<img src="greybox_sol.jpg" width="541" height="489">
<p>

d) The following solution assumes a change to the microsequencer to branch according to the Z condition code.
<p>
<img src="states_vld_ps5.jpg" width="644" height="854">
<p>
</li>

</ol>
</body>
</html>

