	<!--
<li id="io">
<div class="edit_note">(Corrected: 04/15/2007)</div>
<p>We show below a synchronous split transaction bus system employing centralized arbitration. There are two processors (P0 and P1) and two storage devices (S0 and S1). For the sake of simplicity, we assume that processors will only <strong>read</strong> data from the the storage devices.</p>

<img src="tx_rx_system.gif" alt="Logic diagram of a bus system"/>

<h3>Arbitration</h3>
<p>There are two arbitration units, Processor Arbitration Unit(PrAU) and Storage Device Arbitration Unit(SAU). PrAU arbitrates the <var>addr_p</var> bus across P0 and P1.
SAU arbitrates the data bus across S0 and S1. This allows one processor to request a transfer while the other processor is receiving data. 
P0 has higher priority than P1 and S0 has higher priority than S1.</p>

<h3>Data Transfer</h3>
<p>The following is how a transfer between Processor <var>i</var> (P<var>i</var>) and Storage Device <var>j</var> (S<var>j</var>) proceeds:</p>
<ol style="list-style-type: decimal;">
<li>When P<var>i</var> needs data from S<var>j</var>, it asserts the Bus Request signal (PBR<var>i</var>). Upon receiving the Bus Grant signal (PBG<var>i</var>) from the PrAU, the controller asserts the starting address on <var>addr_p</var>, the <var>Vaddr</var> (valid address signal, not shown in the figure), number of elements to be transfered on signal <var>length_p</var> (<var>Count</var>), and its Id (<var>i</var> in this case) on <var>id_p</var> signal. P<var>i</var> now waits for data from S<var>j</var>.
</li>
<li>When S<var>j</var> sees an address that lies in its address range with <var>Vaddr</var> asserted, it latches the address, length, and Id and starts processing the request. </li>
<li>When S<var>j</var> is ready to return a data element, it asserts SBR<var>j</var> and upon receiving the Grant signal (SBG<var>j</var>), it asserts data on <var>data_s</var>, the Id of the processor that requested the data on <var>id_s</var> and the <var>Vid</var> (valid id signal, where <var>Vid</var> = SBG0 OR SBG1, not shown in the figure). It also decrements its <var>Count</var> of the remaining elements. <ins class="edit">The SBG<var>j</var> signal grants the bus to S<var>j</var> for a <em>single</em> cycle.</ins>
</li>
<li>When P<var>i</var> sees its Id on <var>id_s</var> with <var>Vid</var> signal asserted, it latches the data element and decrements its <var>Count</var>. 
</li>
<li>P<var>i</var> and S<var>j</var> cycle through steps 3 and 4 until <var>Count</var> reaches 0.
</li>
</ol>

<p>The device and controller synchronize using the <var>Dev</var> and <var>Ready</var> signals. 
When a transfer needs to be carried out the <var>Dev</var> signal is asserted. The availability of valid data is indicated by asserting the <var>Ready</var> signal.</p>

<p>Note: for the sake of simplicity, assume each processor can have only one pending transfer. 
Each storage <span class="edit"><del>device</del> <ins>controller</ins></span> can buffer up to two requests since each processor could have one pending transfer from a given storage.</p>

<ol>
<li>
<p>Construct the state machine for the processor controller P<var>i</var>.  Show relevant inputs and outputs on all arcs. 
(Remember that the controller keeps track of the number of data transfers completed in a <var>Count</var> <span class="edit"><del>signal</del> <ins>register</ins></span>.)</p>
</li>
<li id="io_state">
<p>Assume that the controller consists of a state machine and a two-entry buffer: <span class="edit_note">(Corrected: 04/12/2007 &ndash; changed directions of Dev and Ready signals)</span></p>
<img src="controller.png" alt="Controller logic diagram showing the two-entry buffer" />
<p>Whenever the storage controller is requested on the bus, the buffer stores the <var>id_p</var>, <var>length_p</var>, and <var>addr_p</var> bus signals. The <var>req</var> output of the buffer indicates that at least one request is awaiting service in the buffer. The <var>id</var>, <var>length</var>, and <var>addr</var> signals are the buffered bus signals of the oldest buffered bus request. The <var>done</var> input tells the buffer to clear the oldest buffered request.</p>
<p>Draw the state diagram for the state machine in the figure above. Show relevant inputs and outputs on all arcs.</p>
</li>
</ol>
</li>

<li>
<p>We added a small cache to the LC-3b processor. The data store
size is 64 bytes and the cache line size is 16 bytes. When a given
program is executed, the processor reads data from the following
sequence of hex addresses:</p>

<pre>x3210, x3212, x3318, x3394, x3214, x3040, x3218, x3394, x3310, x3390</pre>
<p>This pattern is repeated three times.</p>
<ol class="a">
<li>
<p>Show the contents of the cache at the end of each pass throughout
this loop if a direct-mapped cache is used. Compute the hit rate for this
example. Assume that the cache is initially empty.</p>
</li>
<li>
<p>Repeat part (a) for a two way set-associative cache that uses the LRU-replacement
algorithm.</p>
</li>
<li>
<p>Repeat part (a) for a fully-associative cache that uses
the LRU replacement algorithm.</p>
</li>
</ol>
</li><!-- End of Question -->

-->
<li id="scoreboard"><!-- Begin Question -->
<p>Given the following code:</p>

<pre><code>MUL R3, R1, R2
ADD R5, R4, R3
ADD R6, R4, R1
MUL R7, R8, R9
ADD R4, R3, R7
</code>MUL R10, R5, R6</pre>

<p>Note: Each instruction is specified with the destination register first.</p>

<p>Calculate the number of cycles it takes to execute the given code on the 
following models:</p>

<ol type="a">
<li>A non-pipelined machine.</li>
<li>A pipelined machine with scoreboarding and five adders and five multipliers.</li>
<li>A pipelined machine with scoreboarding and one adder and one multiplier.</li>
</ol>

<p>Note: For all machine models, use the basic instruction cycle as follows:</p>
<ul>
<li>Fetch (one clock cycle)</li>
<li>Decode (one clock cycle)</li>
<li>Execute (MUL takes 6, ADD takes 4 clock cycles). The multiplier and the adder are not pipelined.</li>
<li>Write-back (one clock cycle)</li>
</ul>

<p>Do not forget to list any assumptions you make about the pipeline
structure (e.g., data forwarding between pipeline stages). Infact, we encourage
you to solve the above mentioned questions with data forwarding as well, but,
you are not required to do so.</p>
</li><!-- End of Question -->

<li id="branch_prediction"><!-- Begin Question -->
<p>Suppose we have the following loop executing on a pipelined LC-3b machine.</p>

<pre><code>DOIT     STW   R1, R6, #0
         ADD   R6, R6, #2
         AND   R3, R1, R2
         BRz   EVEN
         ADD   R1, R1, #3
         ADD   R5, R5, #-1
         BRp   DOIT
EVEN     ADD   R1, R1, #1
         ADD   R7, R7, #-1 
         BRp   DOIT</code></pre>

<p>Assume that before the loop starts, the registers have the following
<strong>decimal</strong> values stored in them:</p>
<table>
<thead>
<tr><th>Register</th><th>Value</th></tr>
</thead>
<tbody>
<tr><td>R0</td><td>0</td></tr>
<tr><td>R1</td><td>0</td></tr>
<tr><td>R2</td><td>1</td></tr>
<tr><td>R3</td><td>0</td></tr>
<tr><td>R4</td><td>0</td></tr>
<tr><td>R5</td><td>5</td></tr>
<tr><td>R6</td><td>4000</td></tr>
<tr><td>R7</td><td>5</td></tr>
</tbody>
</table>

<p>The fetch stage takes one cycle, the decode stage also takes one cycle, the execute stage takes 
a variable number of cycles depending on the type of instruction (see below), and the store stage takes one cycle.</p>

<p>All execution units (including the load/store unit) are fully pipelined and 
the following instructions that use these units take the indicated number of 
cycles:</p>

<table>
<thead>
<tr><th>Instruction</th><th>Number of Cycles</th></tr>
</thead>
<tbody>
<tr><td>STW</td><td>3</td></tr> 
<tr><td>ADD</td><td>3</td></tr> 
<tr><td>AND</td><td>2</td></tr> 
<tr><td>BR</td><td>1</td></tr>
</tbody>
</table>

<p>Data forwarding is used wherever possible. Instructions that are
dependent on the previous instructions can make use of the results
produced right after the previous instruction finishes the
execute stage.</p>
<p>The target instruction after a branch can be fetched when the
BR instruction is in ST stage. For example, the execution of an ADD instruction followed by a BR would look 
like:</p>

<pre>ADD       F | D | E1 | E2 | E3 | ST
BR            F | D  | -  | -  | E1 | ST
TARGET                                F  | D</pre>

<p>The pipeline implements &ldquo;in-order execution.&rdquo; A scoreboarding scheme is used 
as discussed in class.</p>

<p>Answer the following questions:</p>
<ol type="a">
<li><p>How many cycles does the above loop take to execute if no branch prediction is used?</p></li>
<li><p>How many cycles does the above loop take to execute if all branches are predicted with 100% accuracy.</p></li>
<li><p>How many cycles does the above loop take to execute if a static BTFN (backward taken-forward not taken) branch prediction scheme is used to predict branch directions? What is the overall branch prediction accuracy? What is the prediction accuracy for each branch?</p></li>
</ol>
</li><!-- End of Question -->

<li><!-- Begin Question -->
<p>A five instruction sequence executes according to Tomasulo's
algorithm. Each instruction is of the form <code>ADD DR,SR1,SR2</code> or <code>MUL
DR,SR1,SR2</code>.  ADDs are pipelined and take 9 cycles
(F-D-E1-E2-E3-E4-E5-E6-WB).  MULs are also pipelined and take 11 cycles (two
extra execute stages).  The microengine must wait until a result is in
a register before it sources it (reads it as a source operand).</p>

<p>The register file before and after the sequence are shown
below (tags for &ldquo;After&rdquo; are ignored).</p>

<img src="Table1.jpg" alt="Two register file before and after the instruction sequence" />

<ol type="a">
<li> 
<p>Complete the five instruction sequence in program order in the space below.
Note that we have helped you by giving you the opcode and two source operand
addresses for instruction 4. (The program sequence is unique.)</p>

<img src="Table2.jpg" alt="Space to fill in the five instruction sequence with part of one instruction given" />
</li>
<li>
<p>In cycle 1 instruction 1 is fetched.  In cycle 2,
instruction 1 is decoded and instruction 2 is fetched.  In cycle 3,
instruction 1 starts execution, instruction 2 is decoded, and
instruction 3 is fetched.</p>

<p>Assume the reservation stations are
all initially empty. Put each instruction into the next available
reservation station. For example, the first ADD goes into &ldquo;a&rdquo;. The
first MUL goes into &ldquo;x&rdquo;. Instructions remain in the reservation
stations until they are completed. Show the state of the reservation
stations at the end of cycle 8.</p>

<p>Note: to make it easier for the grader, when allocating source registers
to reservation stations, please always have the higher numbered register be
assigned to SR2.</p>

<img src="Table3.jpg" alt="Two empty reservation stations, one for the adder and one for the multiplier" />
</li>
<li>
<p>Show the state of the Register Alias Table (V, tag, Value) at the end of
cycle 8.</p>

<img src="Table4.jpg" alt="Empty Register Alias Table" />
</li>
</ol>
</li><!-- End of Question -->
