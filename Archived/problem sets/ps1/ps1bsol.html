<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>EE 360N: Problem Set 1b Solution</title>
<link rel="StyleSheet" type="text/css" href="../../main.css" />
<link rel="StyleSheet" type="text/css" href="../probs.css" />
</head>
<body>
<center>
<h3>
Department of Electrical and Computer Engineering
</h3>
<h4>
The University of Texas at Austin
</h4>
</center>

EE 360N, Spring 2007<br />
Problem Set 1b Solution<br />
Yale N. Patt, Instructor<br />
Chang Joo Lee, Rustam Miftakhutdinov, Poorna Samanta, TAs<br />

<ol class="questions">

<li>

<ol>
<li>

<br>
<br>
<table>
<thead>
<tr><th>Symbol</th><th>Address</th></tr>
</thead>
<tr>
<td>AGAIN</td>
<td>x300E</td>
</tr>

<tr>
<td>NO</td>
<td>x3022</td>
</tr>

<tr>
<td>B</td>
<td>x3024</td>
</tr>

<tr>
<td>A</td>
<td>x3026</td>
</tr>
</table>
</li>


<br>
<li>
If the high and low byte of the word stored at location x4000 are equal, 
R5 is set to 1, else to 0.
</li>

<br>
<li>
There are several possible answers to this code
optimization question. Some of these are:

<p>
<ul>
<li>
The programmer used a loop to left shift a value
in R2 by 8 bits. He/she could have done this using a single LC-3b
instruction, LSHF. He/she should have replaced the loop

<pre>AGAIN   ADD R2, R2, R2
        ADD R3, R3, #-1
        BRp AGAIN</pre>

with
   
<pre>        LSHF R2, R2, #8</pre>
<br>
</li>

<li>
Instead of using "subtraction" to compare the high and low byte, the
programmer could have used a single XOR instruction to check the
equality of the two bytes. He/she could have replaced the following
instructions

<pre>        NOT R1, R1
	     ADD R1, R1, #1
	     ADD R2, R2, R1</pre>

with

<pre>        XOR R2, R1, R2</pre>
</li>

<li>
The program is comparing the high byte and low byte of the word in
memory location x4000.  The programmer could have utilized the LDB
instruction to load the high byte and low byte into two separate
registers and compare them.  This way there would be no need for
shifting and masking. The optimized program could look like this:

<pre>        .ORIG   x3000
	AND     R5, R5, #0
	LEA	R0, A
	LDW	R0, R0, #0
	LDB	R1, R0, #0
	LDB	R2, R0, #1
	XOR	R2, R1, R2
	BRnp    NO
	ADD     R5, R5, #1
NO	HALT
A       .FILL   x4000
        .END	 </pre>

</li>
</ol>
</li>

<p>
<li>
	<ol>
		<li><br>
<table><tr><td valign="top"><pre>	.ORIG	x4000<br>MAIN	LEA	R2,L0<br>	JSRR	R2<br>	JSR	L1<br>	HALT<br>	;<br>L0	ADD	R0,R0,#5<br>	RET<br>	;<br>L1	ADD	R1,R1,#5<br>	RET<br>      </pre></td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td valign="top"><pre><br>x4000	xE403<br>x4002	x4080<br>x4004	x4803<br>x4006	xF025<br>&nbsp;<br>x4008	x1025<br>x400A	xC1C0<br>&nbsp;<br>x400C	x1265<br>x400E	xC1C0<br></pre></td></tr></table>
	   </li>
		<li>
As long as the subroutine we are calling is located at most
1023 instructions before the JSR instruction or at most 1024
instructions after the JSR instruction, there is no need to use the
first way, which requires at least two instructions. This is due to
the fact that JSR instruction can change the PC to an address within
the range PC + 2 - 2048 and PC + 2 + 2046, because it uses a limited
offset of 11 bits.
<p>
The method that requires two instructions is necessary if the
subroutine we are calling is not within the range of the JSR
instruction. Note that the JSRR instruction can change the PC to any
address residing in its base register.  The address in the base
register can be set to any address in memory.<br>

<p>
For example if we have a program starting at memory location x3000 and
we would like to call a subroutine starting at memory location 0xF000,
there is no way to do this by just using a JSR instruction at location
x3000. However, we can call the subroutine at 0xF000 using JSRR with
the following sequence of instructions:

<pre>           .ORIG      x3000
           LEA        R0, SUBADDR
           LDW        R1, R0, #0
           JSRR	      R1
           HALT
SUBADDR    .FILL      xF000
           .END</pre>
		</li>
	</ol>



</ol>

</body> 

</html>

