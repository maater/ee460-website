<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>EE 360N - Problem Set 1a</title>
</head>
 <body style="background-color: white; ">
 
<center> 
<h2>&nbsp;Department of Electrical and Computer Engineering</h2>
 
<h3>The University of Texas at Austin</h3>
 </center>
 EE 360N, Spring 2007<br>
 Problem Set 1a <br>
 Due: before class January 29th, 2007<br>
 Yale N. Patt, Instructor<br>
 Chang Joo Lee, Rustam Miftakhutdinov, Poorna Samanta, TAs <br>
 
<p> Instructions: <br>
 You are encouraged to work on the problem set in groups and turn in one problem
set for the entire group. Remember to put all your names on the solution
sheet. Also remember to put the name of the TA in whose discussion section
you would like the problem set turned back to you. </p>

<u> You will need to refer to the assembly language handouts and the LC-3b ISA on the course website. </u>
 
<p> </p>
 
<ol>
   
  <li>Briefly explain the difference between the microarchitecture
level and the ISA level in the transformation hierarchy. What information
does the compiler <em>need</em> to know about the microarchitecture of the
machine for which it's compiling code?     
    <p> Classify the following attributes of LC-3b as either a property of
its microarchitecture or ISA: </p>
     
    <ol>
       
      <li> There is no subtract instruction in LC-3b. </li>
       
      <li> The ALU of LC-3b does not have a subtract unit. </li>
       
      <li> LC-3b has three condition code bits (n, z, and p). </li>
       
      <li> The n, z, and p bits are stored in three 1-bit registers. </li>
       
      <li> A 5-bit immediate can be specified in an ADD instruction </li>
       
      <li> It takes <i>n</i> cycles to execute an ADD instruction. </li>
       
      <li> There are 8 general purpose registers used by operate, data movement
and control instructions. </li>
       
      <li> The registers MDR (Memory Data Register) and MAR (Memory Address Register) are used for Loads and Stores.
      </li>
       
      <li> A 2-to-1 mux feeds one of the inputs to ALU. </li>
       
      <li> The register file has one input and two output ports. </li>
     
    </ol>
   </li>
  <li>Both of the following programs cause the value
x0004 to be stored in location x3000, but they do so at different times.
Explain the difference.     
    <ul>
       
      <li><pre>	.ORIG x3000<br>	.FILL x0004<br>	.END<br>	  </pre> </li>
       
      <li><pre>	.ORIG x4000<br>	AND R0, R0, #0<br>	ADD R0, R0, #4<br>	LEA R1, A<br>	LDW R1, R1, #0<br>	STW R0, R1, #0<br>	HALT<br>A	.FILL x3000	<br>	.END<br>	  </pre> </li>
     
    </ul>
   </li>
 <!-- End Question --> 
    <p> </p>
  <li><!-- Begin Question --> Classify the LC-3b instructions into Operate,
Data Movement, or Control instructions. </li>
 <!-- End Question --> 
    <p> </p>
  <li><!-- Begin Question --> At location x3E00, we would like to put an
instruction that does nothing. Many ISAs actually have an opcode devoted
to doing nothing. It is usually called NOP, for NO OPERATION. The instruction
is fetched, decoded, and executed. The execution phase is to do nothing!
Which of the following three instructions could be used for NOP and have
the program still work correctly?     
    <ol>
       
      <li> <tt>0001 001 001 1 00000</tt><br>
       </li>
       
      <li> <tt>0000 111 000000010</tt><br>
       </li>
       
      <li> <tt>0000 000 000000000</tt><br>
       </li>
     
    </ol>
     
    What does the ADD instruction do that the others do not do?<!-- End Question -->
   </li>
    <p> </p>
   
    <p> </p>
  <li><!-- Begin Question --> Consider the following possibilities for saving
the return address of a subroutine:     
    <ul>
       
      <li> In a processor register. </li>
       
      <li> In a memory location associated with the subroutine. A different
memory location is used for each different subroutine. </li>
       
      <li> On a stack. </li>
     
    </ul>
 Which of these possibilities supports subroutine nesting, and which supports
subroutine recursion (that is, a subroutine that calls itself)? </li>
 <!-- End of Question --> 
    <p> </p>
  <li> A small section of byte-addressable memory is given below:     
    <center>     
    <table border="1">
       <tbody>
         <tr>
           <th> Address </th>
           <th> Data </th>
         </tr>
         <tr>
           <td> x1005 </td>
           <td> x0A </td>
         </tr>
         <tr>
           <td> x1004 </td>
           <td> x0B </td>
         </tr>
         <tr>
           <td> x1003 </td>
           <td> x0C </td>
         </tr>
         <tr>
           <td> x1002 </td>
           <td> x11 </td>
         </tr>
         <tr>
           <td> x1001 </td>
           <td> x1A </td>
         </tr>
         <tr>
           <td> x1000 </td>
           <td> x0E </td>
         </tr>
         <tr>
           <td> x0FFF </td>
           <td> x25 </td>
         </tr>
         <tr>
           <td> x0FFE </td>
           <td> xA2 </td>
         </tr>
       
      </tbody>     
    </table>
     </center>
     <br>
 Add the 16-bit two's complement numbers specified by addresses 0x1000 and
0x1002 if:     
    <ul>
       
      <li> The ISA specifies a little-endian format </li>
       
      <li> The ISA specifies a big-endian format </li>
     
    </ul>
   </li>
    <p> </p>
   
  <li> Say we have 32 mega bytes of storage, calculate the number of
bits required to address a location if     
    <ol>
       
      <li> The ISA is bit-addressable</li>
       
      <li> The ISA is byte-addressable</li>
       
      <li> The ISA is 128-bit addressable </li>
     
    </ol>
   </li>
   
    <p> </p>
  <li>     
    <ul>
       
      <li>A zero-address machine is a stack-based machine where all operations
are done using values stored on the operand stack. For this problem, you
may assume that its ISA allows the following operations:         
        <ul>
           
          <li> PUSH M - pushes the value stored at memory location M onto
the operand stack. </li>
           
          <li> POP M - pops the operand stack and stores the value into memory
location M. </li>
           
<li> OP - Pops two values off the operand stack, performs the binary
operation OP on the two values, and pushes the result back onto the
operand stack. </li><br>
                                                                                         
</ul>
Note: To compute A - B with a stack machine, the following sequence
of operations are necessary: PUSH A, PUSH B, SUB.  After execution of SUB,
A and B would no longer be on the stack, but the value A-B would be at
the top of the stack. <br>
                                                                                         
       </li>
       <br>
       
      <li> A one-address machine uses an accumulator in order to perform computations.
For this problem, you may assume that its ISA allows the following operations: 
        
        <ul>
           
          <li> LOAD M - Loads the value stored at memory location M onto the
accumulator. </li>
           
          <li> STORE M - Stores the accumulator value into Memory Location
M. </li>
           
          <li> OP M - Performs the binary operation OP on the value stored
at memory location M and the value present in the accumulator. The result
is stored back in the accumulator (ACCUM = ACCUM OP M). </li>
         
        </ul>
       </li>
       <br>
       
      <li> A two-address machine takes two sources, performs an operation
on these sources and stores the result back into one of the sources. For
this problem, you may assume that its ISA allows the following operation: 
        
        <ul>
           
          <li> OP M1, M2 - Performs a binary operation OP on the values stored
at memory locations M1 and M2 and stores the result back into memory location
M1 (M1 = M1 OP M2). </li>
         
        </ul>
       </li>
     
    </ul>
     
    <p> Note 1: OP can be ADD, SUB or MUL for the purposes of this problem. </p>
    <p> Note 2: A, B, C, D, E and X refer to memory locations and can be also used to store temporary results. </p>
     
    <ol>
       
      <li> Write the assembly language code for calculating the expression (do not simplify the expression):
        <br>
 X = (A + (B * C)) * (D - (E + ( D * C )))
        <ul>
           
          <li> In a zero-address machine </li>
           
          <li> In a one-address machine </li>
           
          <li> In a two-address machine </li>
           
          <li> In a three-address machine like the LC-3b, but which can do
memory to memory operations and also has a MUL instruction.</li>
         
        </ul>
       </li>
       
      <li> Give an advantage and a disadvantage of a one-address machine versus a zero-address machine.
      </li>
     
    </ol>
   </li>
 <!--      <p></p>
      <li>
      Assume for the following questions that an LC-3b instruction is loaded into a random memory
      location such that it can be executed. 
      <ol>
      <li>
      What is the probability that the instruction is stored in location 0x0057?
      </li>
      <li>
      What is the probability that the instruction is stored in location 0x300E?
      </li>
      </ol >
      </li>
-->
 <!--      <li>
      The LC-3b company wants to increase the number of instructions in the ISA. They have hired
      you to add 64 new instructions to the ISA. Give us a way to increase the number of opcodes
      without having to change the current program binaries. 
      </li> -->
    <p> </p>
 
  <li>The following table gives the format of the instructions for the LC-1b 
computer that has 8 opcodes.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <br>
     <br>
     <br>
     
    <table cellpadding="0" cellspacing="1" border="1" style="width: 504px; height: 269px; ">
       <tbody>
         <tr>
           <td style="text-align: center; vertical-align: middle; ">Opcode</td>
           <td style="vertical-align: top; text-align: center; ">7&nbsp; &nbsp;
6 &nbsp; &nbsp; 5</td>
           <td style="vertical-align: top; text-align: center; ">4&nbsp;&nbsp; 
&nbsp; 3</td>
           <td style="vertical-align: top; text-align: center; ">2<br>
           </td>
           <td style="vertical-align: top; text-align: center; ">1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
0<br>
           </td>
         </tr>
         <tr>
           <td style="vertical-align: top; text-align: center; ">ADD<br>
           </td>
           <td style="vertical-align: top; text-align: center; ">0&nbsp;&nbsp;&nbsp;&nbsp; 
0&nbsp;&nbsp;&nbsp; 0<br>
           </td>
           <td style="vertical-align: top; text-align: center; ">DR<br>
           </td>
           <td style="vertical-align: top; text-align: center; ">A<br>
           </td>
           <td style="vertical-align: top; text-align: center; ">SR<br>
           </td>
         </tr>
         <tr>
           <td style="vertical-align: top; text-align: center; ">AND<br>
           </td>
           <td style="vertical-align: top; text-align: center; ">0&nbsp;&nbsp;&nbsp;&nbsp; 
0&nbsp;&nbsp;&nbsp; 1<br>
           </td>
           <td style="vertical-align: top; text-align: center; ">DR</td>
           <td style="vertical-align: top; text-align: center; ">A</td>
           <td style="vertical-align: top; text-align: center; ">SR</td>
         </tr>
         <tr>
           <td style="vertical-align: top; text-align: center; ">BR(R)<br>
           </td>
           <td style="vertical-align: top; text-align: center; ">0&nbsp;&nbsp;&nbsp;&nbsp; 
1 &nbsp;&nbsp; 0</td>
           <td style="vertical-align: top; text-align: center; "colspan="2">N&nbsp;&nbsp;&nbsp; 
Z&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P <br>
           </td>
            <td style="vertical-align: top; text-align: center; ">TR<br>
           </td>
         </tr>
         <tr>
           <td style="vertical-align: top; text-align: center; ">LDImm<br>
           </td>
           <td style="vertical-align: top; text-align: center; ">0&nbsp;&nbsp;&nbsp;&nbsp; 
1 &nbsp;&nbsp; 1<br>
           </td>
           <td style="vertical-align: top; text-align: center; " colspan="3">
signed immediate<br>
           </td>
         </tr>
         <tr>
           <td style="vertical-align: top; text-align: center; ">LEA<br>
           </td>
           <td style="vertical-align: top; text-align: center; ">1&nbsp;&nbsp;&nbsp;&nbsp; 
0&nbsp;&nbsp;&nbsp; 0</td>
           <td style="vertical-align: top; text-align: center; " colspan="3">
signed offset <br>
           </td>
         </tr>
         <tr>
           <td style="vertical-align: top; text-align: center; ">LD<br>
           </td>
           <td style="vertical-align: top; text-align: center; ">1&nbsp;&nbsp;&nbsp;&nbsp; 
0&nbsp;&nbsp;&nbsp; 1<br>
           </td>
           <td style="vertical-align: top; text-align: center; ">DR</td>
           <td style="vertical-align: top; text-align: center; ">0<br>
           </td>
           <td style="vertical-align: top; text-align: center; ">TR<br>
           </td>
         </tr>
         <tr>
           <td style="vertical-align: top; text-align: center; ">ST<br>
           </td>
           <td style="vertical-align: top; text-align: center; ">1&nbsp;&nbsp;&nbsp;&nbsp; 
1 &nbsp;&nbsp; 0</td>
           <td style="vertical-align: top; text-align: center; ">SR</td>
           <td style="vertical-align: top; text-align: center; ">0<br>
           </td>
           <td style="vertical-align: top; text-align: center; ">TR</td>
         </tr>
         <tr>
           <td style="vertical-align: top; text-align: center; ">NOT<br>
           </td>
           <td style="vertical-align: top; text-align: center; ">1&nbsp;&nbsp;&nbsp;&nbsp; 
1 &nbsp;&nbsp; 1<br>
           </td>
           <td style="vertical-align: top; text-align: center; ">DR</td>
           <td style="vertical-align: top; text-align: center; ">0<br>
           </td>
           <td style="vertical-align: top; text-align: center; ">0&nbsp;&nbsp;&nbsp;&nbsp; 
0<br>
           </td>
         </tr>
       
      </tbody>     
    </table>

<pre> 

Notes :
                                                                                
        Interpretation of all instructions is similar to that of the LC-3b,
        unless specifically stated otherwise.
                                                                                
        The destination register for the instructions LDImm and
        LEA is always register R0.
        (e.g.   LDImm #12  loads decimal 12 to register R0.)
                                                                                
        TR stands for Target Register.  In the case of the conditional
        branch instruction BR, it contains the target address of the branch.
        In the case of LD, it contains the address of the source.  In the
        case of ST, it contains the address of the destination.
                                                                                
        ADD and AND provide immediate addressing by means of a steering bit,
        bit[2], labeled A.  If  A is 0, the second source operand is obtained
        from SR. If A is 1, the second source operand is obtained by
        sign-extending bits[1:0] of the instruction. A bit is called a
        Steering Bit if its value "steers" the interpretation of other bits
        (instruction bits 1:0 in this case).

        Bits labeled 0 must be zero in the encoding of the instruction.

</pre>

    <ol>
    <li>What kind of machine (n-address) does the above ISA specification
represent?</li>
     
    <li>How many general purpose registers does the machine have?</li>
     
    <li>Using the above instructions, write the assembly code to implement
a register to register mov operation. <br>
     </li>
     
    <li>How can we make a PC-relative branch? (HINT: You will need more than one LC-1b instruction)
    </li>
   
    </ol>
   </li>
</ol>
 
</body>
</html>
