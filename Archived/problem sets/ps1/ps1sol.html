<html>
  <head>
    <title>EE 360N - Problem Set 1 Solutions</title>
  </head>

<body bgcolor=white text=black>

<center>
<h3>
Department of Electrical and Computer Engineering
</h3>
<h4>
The University of Texas at Austin
</h4>
</center>

EE 360N, Spring 2007 <br>
Problem Set 1 Solutions <br>
Yale N. Patt, Instructor
<br>
Chang Joo Lee, Rustam Miftakhutdinov, Poorna Samanta, TAs <br>

<p>

<ol>

<li>
The ISA is the contract between the hardware and the software. The microarchitecture is a particular implementation of an ISA. 
Compiler does not need to know any information about the microarchitecture.
<p>
  <ol>
  <li> ISA
  <li> Microarchitecture
  <li> ISA
  <li> Microarchitecture 
  <li> ISA
  <li> Microarchitecture/ISA
  <li> ISA
  <li> Micorarchitecture
  <li> Micorarchitecture 
  <li> Micorarchitecture
</ol>
</li>

<p>

<!-- <li>
 None. 
</li>
!-->

<p>

<li>
The first program causes x0004 to be stored in location x3000 when the assembled code is loaded into the memory. The second program causes x0004 to be stored in x3000 during the execution of the program.
</li>

<p>

<li>

The following table shows the classification of the LC-3b instructions into Operate, Data Movement and Control instructions.

<p>

<table border=1>
<tr>
<th> Instruction </th><th> Operate </th><th> Data Movement </th><th> Control </th>
</tr>
<tr align="center"><td> ADD </td> <td> X </td> <td> &nbsp; </td> <td> &nbsp; </td></tr>
<tr align="center"><td> AND </td> <td> X </td> <td> &nbsp; </td> <td> &nbsp; </td></tr>
<tr align="center"><td> BR </td>  <td> &nbsp; </td> <td> &nbsp; </td> <td> X </td></tr>
<tr align="center"><td> JMP/RET </td> <td> &nbsp; </td> <td> &nbsp; </td> <td> X </td></tr>
<tr align="center"><td> JSR/JSRR </td> <td> &nbsp; </td> <td> &nbsp; </td> <td> X </td></tr>
<tr align="center"><td> LDB </td> <td> &nbsp; </td> <td> X </td> <td> &nbsp; </td></tr>
<tr align="center"><td> LDW </td> <td> &nbsp; </td> <td> X </td> <td> &nbsp; </td></tr>
<tr align="center"><td> LEA </td> <td> &nbsp; </td> <td> X </td> <td> &nbsp; </td></tr>
<tr align="center"><td> RTI </td> <td> &nbsp; </td> <td> &nbsp; </td> <td> X </td></tr>
<tr align="center"><td> SHF </td> <td> X </td> <td> &nbsp; </td> <td> &nbsp; </td></tr>
<tr align="center"><td> STB </td> <td> &nbsp; </td> <td> X </td> <td> &nbsp; </td></tr>
<tr align="center"><td> STW </td> <td> &nbsp; </td> <td> X </td> <td> &nbsp; </td></tr>
<tr align="center"><td> TRAP </td> <td> &nbsp;</td> <td> &nbsp; </td> <td> X </td></tr>
<tr align="center"><td> XOR/NOT </td> <td> X </td> <td> &nbsp; </td> <td> &nbsp; </td></tr>
</table>


<p>

<li>
Only the third instruction (never branch) can be used as a NOP. The second instruction always skips
the next instruction after it, so it is not a NOP. The first instruction (ADD) sets the condition codes based on the 
value in R1, therefore it is also not a NOP.
</li>

<p>
<li>

<ol>
<li>

<br>
<br>
<table BORDER CELLSPACING=0 COLS=2 WIDTH="200" NOSAVE >
<tr NOSAVE>
<td NOSAVE>
<center>Symbol</center>
</td>
<td>
<center>Address</center>
</td>
</tr>
<tr NOSAVE>
<td ><tt>AGAIN</tt></td>
<td><tt>x300E</tt></td>
</tr>

<tr NOSAVE>
<td><tt>NO</tt></td>
<td NOSAVE><tt>x3022</tt></td>
</tr>

<tr>
<td><tt>B</tt></td>
<td><tt>x3024</tt></td>
</tr>

<tr NOSAVE>
<td><tt>A</tt></td>
<td NOSAVE><tt>x3026</tt></td>
</tr>
</table>
</li>

<br>
<!-- <li>

<pre>0x3000
0x5B60
0x56E0
0x16E8
0xE00E
0x6201
0x6240
0x1460
0x1482
0x16FF
0x03FD
0x6800
0x5244
0x927F
0x1261
0x1481
0x0A01
0x1B61
0xF025
0xFF00
0x4000</pre>
</li>

!-->

<br>
<li>
If the high and low byte of the word stored at location x4000 are equal, 
R5 is set to 1, else to 0.
</li>

<br>
<li>
There are several possible answers to this code
optimization question. Some of these are:

<p>
<ul>
<li>
The programmer used a loop to left shift a value
in R2 by 8 bits. He/she could have done this using a single LC-3b
instruction, LSHF. He/she should have replaced the loop

<pre>AGAIN   ADD R2, R2, R2
        ADD R3, R3, #-1
        BRp AGAIN</pre>

with
   
<pre>        LSHF R2, R2, #8</pre>
<br>
</li>

<li>
Instead of using "subtraction" to compare the high and low byte, the
programmer could have used a single XOR instruction to check the
equality of the two bytes. He/she could have replaced the following
instructions

<pre>        NOT R1, R1
	     ADD R1, R1, #1
	     ADD R2, R2, R1</pre>

with

<pre>        XOR R2, R1, R2</pre>
</li>

<li>
The program is comparing the high byte and low byte of the word in
memory location x4000.  The programmer could have utilized the LDB
instruction to load the high byte and low byte into two separate
registers and compare them.  This way there would be no need for
shifting and masking. The optimized program could look like this:

<pre>        .ORIG   x3000
	AND     R5, R5, #0
	LEA	R0, A
	LDW	R0, R0, #0
	LDB	R1, R0, #0
	LDB	R2, R0, #1
	XOR	R2, R1, R2
	BRnp    NO
	ADD     R5, R5, #1
NO	HALT
A       .FILL   x4000
        .END	 </pre>

</li>
</ol>
</li>

<p>
<li>
	<ol>
		<li><br>
<table><tr><td valign="top"><pre>	.ORIG	x4000<br>MAIN	LEA	R2,L0<br>	JSRR	R2<br>	JSR	L1<br>	HALT<br>	;<br>L0	ADD	R0,R0,#5<br>	RET<br>	;<br>L1	ADD	R1,R1,#5<br>	RET<br>      </pre></td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td valign="top"><pre><br>x4000	xE403<br>x4002	x4080<br>x4004	x4803<br>x4006	xF025<br>&nbsp;<br>x4008	x1025<br>x400A	xC1C0<br>&nbsp;<br>x400C	x1265<br>x400E	xC1C0<br></pre></td></tr></table>
	   </li>
		<li>
As long as the subroutine we are calling is located at most
1023 instructions before the JSR instruction or at most 1024
instructions after the JSR instruction, there is no need to use the
first way, which requires at least two instructions. This is due to
the fact that JSR instruction can change the PC to an address within
the range PC + 2 - 2048 and PC + 2 + 2046, because it uses a limited
offset of 11 bits.
<p>
The method that requires two instructions is necessary if the
subroutine we are calling is not within the range of the JSR
instruction. Note that the JSRR instruction can change the PC to any
address residing in its base register.  The address in the base
register can be set to any address in memory.<br>

<p>
For example if we have a program starting at memory location x3000 and
we would like to call a subroutine starting at memory location 0xF000,
there is no way to do this by just using a JSR instruction at location
x3000. However, we can call the subroutine at 0xF000 using JSRR with
the following sequence of instructions:

<pre>           .ORIG      x3000
           LEA        R0, SUBADDR
           LDW        R1, R0, #0
           JSRR	      R1
           HALT
SUBADDR    .FILL      xF000
           .END</pre>
		</li>
	</ol>

<p>

<!-- 
<li>

 The LC-3b uses five addressing modes. They are:    	   

<ol>
<li>Immediate addressing, e.g., <tt>ADD  R0, R1, #10</tt> </li>
<li>Register addressing, e.g., <tt>ADD  R1, R2, R3</tt> </li>
<li>Register + Offset addressing, e.g., <tt>LDW  R1, R0, #5</tt> </li>
<li>PC-relative addressing, e.g., <tt>LEA R1, LABEL</tt> </li>
<li>Direct addressing, e.g., <tt>TRAP x25</tt> </li>
</ol>
</li>
!-->


<li>
<ol>
<li> The first option does not support either subroutine nesting or subroutine recursion. </li>
<li> The second option supports subroutine nesting, but does not support recursion. </li>
<li> The third option supports both subroutine nesting and subroutine recursion. </li>
</ol>
</li>


<p>
<li>
<ol>
<li> Little endian: MEM[x1000] + MEM [x1002] = x1A0E + x0C11 = x261F </li>
<li> Big endian:    MEM[x1000] + MEM [x1002] = x0E1A + x110C = x1F26 </li>
</ol>
</li>


<p>
<li>
32 Megabytes = 2^28 bits
<ol>
<li>The memory consists of 2^28 addressable locations. 28 bits are required to uniquely address each location.</li>
<li>The memory consists of 2^28/2^3 = 2^25 addressable locations. 25 bits are required to address a location.</li>
<li>The memory consists of 2^28/2^7 = 2^21 addressable locations. 21 bits are required to address a location.</li>
</ol>
<p>

<!-- <li> 
<pre>XOR  R2, R1, R2
XOR  R1, R1, R2
XOR  R2, R1, R2</pre>
</li>
!-->

<p>
<li>
<ol>
<li> Zero-address machine:
<pre>PUSH A
PUSH B
PUSH C
MUL
ADD
PUSH D
PUSH E
PUSH D
PUSH C
MUL
ADD
SUB
MUL
POP X</pre>
Advantage: Good for fast arithmetic. Operate instructions only require
an opcode, so they can be encoded very densely.
<br>
Disadvantage: Not flexible in terms of manipulating operands. More
instructions required to write programs.

<p>
<li> One-address machine:
<pre>LOAD B
MUL C
ADD A
STORE A
LOAD C
MUL D
ADD E
STORE E
LOAD D
SUB E
MUL A
STORE X</pre>
Advantage: Only a single register required. Fewer instructions compared to the stack machine.
<br>
Disadvantage: Not as flexible as 2 or 3-address machines. We need
instructions to move data to and from the accumulator (We don't need
these in a 3-address machine that supports memory-to-memory
operations).

<p>
<li> Two-address machine:
<pre>MUL B, C
ADD A, B
MUL C, D
ADD C, E
SUB D, C
MUL A, D
SUB X, X   ; these two instructions emulate a MOV X, A
ADD X, A</pre>
<!--
Advantage: More flexibility in sources and destinations compared to
stack and accumulator machines.
<br>
Disadvantage: One source is always overwritten. We need MOV
instructions to preserve the original value of a source operand.
-->
<p>
<li> Three-address machine:
<pre>MUL X, B, C
ADD A, X, A
MUL X, D, C
ADD X, E, X
SUB X, D, X
MUL X, X, A</pre>
<!--
Advantage: Most flexible in terms of specifying sources and
destinations of instructions.
<br>
Disadvantage: Larger instructions.  
-->
</ol>

<p>
<!-- 
<li> We could utilize one of the unused opcodes in the
LC-3b ISA to extend the number of opcodes.  For example, we can take
the instruction with opcode 1010 and make bits [11:6] part of the
opcode if bits [15:12] are 1010.  As a result of this we will have 64
new instructions all of which have their bits [15:12] set to 1010.
</li>
!-->
<li>
<p>
   <ol>
   <li> 2 address machine.
   <li> 4 registers
   <li> Lets say you want Mov R2, R1    (R2 = R1)
   <pre>   AND R2, #0
   ADD R2, R1
   </pre>
   <br> or
   <br> 
   <pre>   LEA  TEMP   ; Absolute address of TEMP in R0
   ST   R1, R0 
   LD   R2, R0
   ....
   ....
   <br> TEMP  .FILL  xDEAD  ; any garbage value
   </pre>	
   <li> Use LEA instruction.      
   <pre>   		LEA LABEL
		BR  R0
		....
   LABEL		....	; Branch to this line
</ol>

</li>

<li>
	<ol>
		<li>Memory addressability is the size of the data at every memory location. The Memory Data Register (MDR) size determines the maximum width of each memory data transfer, which is at least the memory addresability. Therefore, the MDR size must be at least 64 bits. E.g. LC-3b is byte-addressable, but the MDR size is 16 bits because 2 bytes can be transferred simultaneously. The Memory Address Register (MAR) size defines the size of the memory address space, which is not related to the addressability.</li>
		<li>We need more than 16 bits to encode the instruction. Therefore, the ISA might becomes variable length, non-uniform decode. Or we could use all 32-bit instructions to keep the ISA fixed length, uniform decode, at the expense of bigger code (i.e. fetch bandwidth, worse I-cache performance, etc.).</li>
	</ol>
</li>

</ol>

</body> 

</html>

