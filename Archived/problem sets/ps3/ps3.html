<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>EE 460N: Problem Set 3</title>
<link rel="StyleSheet" type="text/css" href="../../main.css" />
<link rel="StyleSheet" type="text/css" href="../probs.css" />
</head>
<body>

<center>
<h2>Department of Electrical and Computer Engineering</h2>
</center>

<center>
<h3>The University of Texas at Austin</h3>
</center>

EE 460N, Spring 2013
<br />Problem Set 3
<br />Due: March 4, before class
<br />Yale N. Patt, Instructor
<br />Faruk Guvenilir, Sumedha Bhangale, Stephen Pruett, TAs
<h2>Instructions</h2>
<p>You are encouraged to work on the problem set in groups and turn in
one problem set for the entire group. Remember to put all your names on
the solution sheet. Also remember to put the name of the TA in whose discussion
section you would like the problem set returned to you.</p>
<h2>Questions</h2>

<ol class="questions">

<!-- End Question -->

<!-- Begin Question -->
<li> 
<p>Consider the following piece of code:</p>
<pre><code>     for(i = 0; i &lt; 8; ++i){
       for(j = 0; j &lt; 8; ++j){
         sum = sum + A[i][j];
       }
     }</code></pre>
<p>The figure below shows an 8-way interleaved, byte-addressable memory.
The total size of the memory is 4KB. The elements of the 2-dimensional
array, <var>A</var>, are 4-bytes in length and are stored in the memory in column-major 
order (i.e., columns of <var>A</var> are stored in consecutive memory locations) as shown. 
The width of the bus is 32 bits, and each memory access takes 10 cycles.
</p>
<img alt="" src="interleave2_bank.JPG" />
<p>
A more detailed picture of the memory chips in Rank 0 of Bank 0 is shown below.
</p>
<img alt="" src="interleave_detail.gif" />
<ol>
<li><p>Since the address space of the memory is 4KB, 12 bits are needed to uniquely
identify each memory location, i.e., <code>Addr[11:0]</code>. Specify which bits of the address 
will be used for:</p>
<ul>
<li>Byte on bus<pre>Addr[_____:_____]</pre></li>
<li>Interleave bits<pre>Addr[_____:_____]</pre></li>
<li>Chip address<pre>Addr[_____:_____]</pre></li>
<li>Rank bits<pre>Addr[_____:_____]</pre></li>
</ul>
</li>
<li><p>How many cycles are spent accessing memory during the execution of the above code? 
Compare this with the number of memory access cycles it would
take if the memory were not interleaved (i.e., a single 4-byte wide array).</p>
</li>
<li><p>Can any change be made to the current interleaving scheme to optimize the number of 
cycles spent accessing memory? If yes, which bits of the address will be used to specify
the byte on bus, interleaving, etc. (use the same format as in part <i>a</i>)? With 
the new interleaving scheme, how many cycles are spent accessing memory? Remember that 
the elements of <var>A</var> will still be stored in column-major order.</p>
</li>
<li><p>Using the original interleaving scheme, what small changes can be made to the 
piece of code to optimize the number of cycles spent accessing memory? How many
cycles are spent accessing memory using the modified code?</p>
</li>
</ol>
</li>
<!-- End Question -->

<!-- Begin Question -->
<li> 
<p>The figure below illustrates the logic and
memory to support 512 MB (byte addressable) of physical memory, supporting
unaligned accesses. The ISA contains <code>LDByte</code>, <code>LDHalfWord</code>, <code>LDWord</code>,
<code>STByte</code> , <code>STHalfWord</code> and <code>STWord</code> instructions, where a word is 32 bits. Bit 28 
serves as a chip enable (active high). If this bit is high the data of the 
memory is loaded on the bus, otherwise the output of the memory chip floats (tri-stated).
</p>
<img alt="" src="unaligned_access.gif" height="760" width="690" />
<p>Note: the byte rotators in the figure are right rotators.</p>
<p>Construct the truth table to implement the LOGIC block, having inputs <code>SIZE</code>, <code>R/W</code>, 
1st or 2nd access, <code>PHYS_ADDR[1:0]</code> and the outputs shown in the above figure. Assume 
that the value of <code>SIZE</code> can be <code>Byte</code> (<code>00</code>), <code>HalfWord</code> (<code>01</code>), and <code>Word</code> (<code>10</code>). Clearly 
explain what function each output serves.</p>
</li>
<!-- End Question -->


<li><p>A bit-serial transmitter-receiver system operates at 1 GHz. It appends an even parity bit after every eight bits processed, as described in class. Therefore, for each byte of data, it transmits a nine bit message. Since the system is bit-serial, one message bit is transmitted each cycle. Assume that the probability of a bit being flipped while it is being transmitted is 10<sup>-7</sup>. In your solution, treat bit flips as statistically independent events.</p>
<ol>
<li><p>What is the probability that a transmitted nine bit message will have one <em>or more</em> flipped bits? Hint: what is the probability that a transmitted nine bit message will have <em>zero</em> flipped bits?</p></li>
<li><p>If the parity check logic in the receiver detects an error in a message, how many bits may have been flipped in that message? (1, 2, 3, 4, 5, 6, 7, 8, 9 &ndash; circle all that apply).</p></li>
<li><p>If the parity check logic in the receiver <em>does not</em> detect an error in a message, how many bits may have been flipped in that message? (1, 2, 3, 4, 5, 6, 7, 8, 9 &ndash; circle all that apply).</p></li>
<li><p>What is the probability that a transmitted nine bit message will have exactly:</p>
<ul>
<li>1 bit flipped</li>
<li>2 bits flipped</li>
<li>3 bits flipped</li>
</ul>
<p>Notice that the probability of exactly three bits being flipped is negligible compared to the probabilities of one or two bits being flipped. Thus, for the rest of this problem, you may neglect the probabilities of three or more bits being flipped in one message.</p>
</li>
<li>On average, how many <em>detected</em> bit errors per second will occur in the system?</li>
<li>On average, how many <em>undetected</em> bit errors per second will occur in the system?</li>
</ol>

<p><strong>Note:</strong> this course is not about probability theory, and the undergraduate probability course (EE351K) is not a prerequisite. Thus, if you have difficulty solving this problem, please see one of the TA's.</p>

</li> 

<!--
<li>
<p>The LC-3b state diagram handed out in class contained errors in states 4, 20, and 21. We have posted both versions of the handout: <a href="state_wrong.pdf">wrong</a> and <a href="../../handouts/state_fixed.pdf">corrected</a>. Briefly explain the problem we have corrected.</p>
</li>


<li>
<p>We discussed in class the various ways to build a rotator out of muxes. In this question, we ask you to compare two designs of a 32-bit left rotator: 1) one level of 32-to-1 muxes, and 2) three levels (4-to-1 muxes, 2-to-1 muxes, 4-to-1 muxes). In particular, we ask you to calculate the number of AND, OR, and NOT gates necessary for each of those designs.</p>
<p>As you know, one way to implement a 2<sup><var>N</var></sup>-to-1 mux is the simple NOT-AND-OR approach (shown below).</p>
<img src="mux.png" alt="NOT-AND-OR implementation of a mux" />
<p>To make grading easier, please use this mux implementation in your calculations. Note: please provide separate counts for each type of gate (AND, OR and NOT) <em>and</em> the number of inputs. For example, your answer should not be &ldquo;655 AND gates&rdquo; if it happened to be &ldquo;400 2-input AND gates, 200 3-input AND gates, and 55 4-input AND gates.&rdquo;</p>
<p>After doing the calculations, which design do you think costs less hardware?</p>
</li>
-->

<!-- Begin Question -->
<li>
<p>If the latency of a DRAM memory bank is 37 cycles, into how many banks
would you interleave this memory in order to fully hide this latency
when making sequential memory accesses?</p>
</li>
<!-- End Question -->

<li><!-- Begin Question -->
<p>An ISA supports an 8-bit, byte-addressable virtual address space. The
corresponding physical memory has only 128 bytes. Each page contains 16
bytes. A simple, one-level translation scheme is used and the page table 
resides in physical memory. The initial contents of the frames of physical
memory are shown below.</p>
<table>
<thead>
<tr>
<th>Frame Number</th><th>Frame Contents</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>empty</td>
</tr>
<tr>
<td>1</td>
<td>Page 13</td>
</tr>
<tr>
<td>2</td>
<td>Page 5</td>
</tr>
<tr>
<td>3</td>
<td>Page 2</td>

</tr>
<tr>
<td>4</td>
<td>empty</td>
</tr>
<tr>
<td>5</td>
<td>Page 0</td>
</tr>
<tr>
<td>6</td>
<td>empty</td>
</tr>
<tr>
<td>7</td>
<td>Page Table</td>
</tr>
</tbody>
</table>

<p>A three-entry Translation Lookaside Buffer that uses LRU replacement is 
added to this system. Initially, this TLB contains the entries for pages
0, 2, and 13. For the following sequence of references, put a circle around
those that generate a TLB hit and put a rectangle around those that generate 
a page fault. What is the hit rate of the TLB for this sequence of references?
(Note: LRU policy is used to select pages for replacement in physical 
memory.)</p>
<p>References (to pages): 0, 13, 5, 2, 14, 14, 13, 6, 6, 13, 15, 14, 15, 13, 4, 3.</p>
<ol>
<li>At the end of this sequence, what three entries are contained in the TLB?</li>
<li>What are the contents of the 8 physical frames?</li>
</ol>
</li><!-- End Question -->

<li><!-- Begin Question -->
<p>We have been referring to the LC-3b memory as 2^16 bytes of memory,
byte-addressable. This is the memory that the user sees, and may bear
no relationship to the actual physical memory. Suppose that the actual
physical address space is 8K bytes, and our page size is 512
bytes. What is the size of the PFN? Suppose we have a virtual
memory system in which virtual memory is divided
into User Space and System Space, and System Page Table remains
resident in physical memory. System space includes trap vector table,
interrupt vector table, operating system and supervisor stack as shown
in Figure A.1 in Appendix A. The rest of the address space 
in Figure A.1 is user space. If each PTE contained, in addition to the
PFN, a Valid bit, a modified bit, and two bits of access control, how
many bits of physical memory would be required to store the System
Page Table?</p>

</li><!-- End Question -->

<li><!-- Begin Question -->
<p>A machine with 64KB, byte addressable virtual memory and 4KB physical
memory has two-level virtual address translation similar to the VAX.
The page size of this machine is 256 bytes. Virtual address space is
partitioned into the P0 space, P1 space, system space and reserved
space.  The space a virtual address belongs to is specified by the
most significant two bits of the virtual address, with 00 indicating
P0 space, 01 indicating P1 space, and 10 indicating system
space. Assume that the PTE is 32 bits and contains only the Valid bit 
and the PFN in the format V0000000..000PFN.</p>

<p>
For a single load instruction the physical memory was accessed three
times, <em>excluding instruction fetch</em>. The 
first access was at location <code>x108</code> and the value read from
that location (<code>x108</code>, <code>x109</code>, <code>x10A</code>, <code>x10B</code>) was <code>x80000004</code>. Hint: What does
this value mean?
</p>
<p>The second access was at location <code>x45C</code> and the third access was at
location <code>x942</code>.
</p>
<p>If SBR = <code>x100</code>, P0BR = <code>x8250</code> and P1BR = <code>x8350</code>,</p>
<ol>
<li>What is  the virtual address corresponding to physical address <code>x45C</code>?</li>
<li>What is 32 bit value read from location <code>x45C</code>?</li>
<li>What is the virtual address corresponding to physical address <code>x942</code>?</li>
</ol>
</li><!-- End Question -->

<li><!-- Begin Question -->
<p><b> Note: In this problem, the PTBR does not point to the first entry in the user space
page table, which actually starts at 0x3A0. This is an optimization to make it easier for the machine
to index into the user space page table .</b></p> 
<p>Consider a processor that supports a 9-bit physical address space with byte
addressable memory. We would like the processor to support a virtual memory system.
The features of the virtual memory system are:</p>
<pre>    Virtual Memory Size : 4 Kbytes (12 bit address-space)
    Page Size           : 32 bytes
    PTBR                : 0x380
    SBR                 : 0x1E0</pre> 
<p>The virtual memory is divided into two spaces: system space and user 
space. System space is the first kilobyte of the virtual address space (i.e., most 
significant two bits of the virtual address are 00). The rest of the virtual memory is 
user space. The system page table remains resident in physical memory. 
Each PTE contains, in addition to the PFN, a Valid bit, a modified bit and 2 bits for access
control. The format of the PTE is</p>

<table>       
<tr>
<td>Valid</td>
<td>Modified</td>
<td>Access Control</td>
<td>PFN</td>
</tr>
</table>

<p>(Valid bit is the most significant bit of the PTE and the PFN is stored 
in the least significant bits.)</p>
 
<ol>
<li><p>How many virtual pages does the system accommodate?</p></li>
<li><p>What is the size of the PFN? How big is the PTE?</p></li>
<li><p>How many bytes are required for storing the entire user space pagetable? How many pages does this correspond to?</p></li>

<li>
<p>Since the user space page table can occupy a significant 
portion of the the physical memory, this system uses a 2 level address translation 
scheme, by storing the user space Page Table in virtual 
memory (similar to VAX).</p>

<p>Given the virtual address 0x7AC what is the Physical address?</p>

<p>The following table shows the contents of the physical memory that you may 
need to do the translation:</p>

<table>
<tr>
<td>
	  <table>	    
	    <tr>
	      <th>Address</th>
	      <th>Data</th>
	      </tr>
	    <tr>
	      <td>
		<code>x1F8</code>
	      </td>
	      <td>
		<code>xBA</code>
	      </td>
	    </tr>

	    <tr>
	      <td>
		<code>x1F9</code>
	      </td>
	      <td>
		<code>xBB</code>
	      </td>
	    </tr>
	    <tr>
	      <td>
		<code>x1FA</code>
	      </td>
	      <td>
		<code>xBC</code>
	      </td>
	    </tr>
	    <tr>
	      <td>
		<code>x1FB</code>
	      </td>
	      <td>
		<code>xBD</code>
	      </td>	 
	    </tr>
	    <tr>
	      <td>
		<code>x1FC</code>
	      </td>
	      <td>
		<code>xBE</code>
	      </td>
	    </tr>
	    <tr>
	      <td>
		<code>x1FD</code>
	      </td>
	      <td>
		<code>xB8</code>
	      </td>
	    </tr>
	    <tr>
	      <td>
		<code>x1FE</code>
	      </td>
	      <td>
		<code>xB7</code>
	      </td>
	    </tr>	    
	    <tr>
	      <td>
		<code>x1FF</code>
	      </td>
	      <td>
		<code>xB6</code>
	      </td>
	    </tr>
	  </table>
</td><td>
	  <table>	    
	    <tr>
	      <th>Address</th>
	      <th>Data</th>
	      </tr>
	    <tr>
	      <td>
		<code>x118</code>
	      </td>
	      <td>
		<code>x81</code>
              </td>
	    </tr>

	    <tr>
	      <td>
		<code>x119</code>
	      </td>
	      <td>
		<code>x72</code>
	      </td>
	    </tr>
	    <tr>
	      <td>
		<code>x11A</code>
	      </td>
	      <td>
		<code>x65</code>
	      </td>
	    </tr>
	    <tr>
	      <td>
		<code>x11B</code>
	      </td>
	      <td>
		<code>x34</code>
	      </td>	 
	    </tr>
	    <tr>
	      <td>
		<code>x11C</code>
	      </td>
	      <td>
		<code>x97</code>
	      </td>
	    </tr>
	    <tr>
	      <td>
		<code>x11D</code>
	      </td>
	      <td>
		<code>x83</code>
	      </td>
	    </tr>
	    <tr>
	      <td>
		<code>x11E</code>
	      </td>
	      <td>
		<code>xC6</code>
	      </td>
	    </tr>	    
	    <tr>
	      <td>
		<code>x11F</code>
	      </td>
	      <td>
		<code>xB2</code>
	      </td>
	    </tr>
	  </table>
  </td></tr></table>
</li>
</ol>
</li><!-- End Question -->

<li><!-- Begin Question -->
<p>The virtual address of variable <var>X</var> is <code>x3456789A</code>. Find the physical address 
of <var>X</var>. Assume a Virtual Memory model similar to VAX.</p>
<p>Remember that in VAX each Virtual Address consists of:</p>
<ul>
<li>2 bits to specify the Address Space</li>
<li>21 bits to specify Virtual Page Number</li>
<li>9 bits to specify the byte on the page</li>
</ul>

<p>You will need to know the contents of P0BR: <code>x8AC40000</code> and SBR: <code>x000C8000</code>.</p>

<p>You will also need to know the contents of the following physical memory locations:</p>
<pre>x1EBA6EF0:&nbsp;&nbsp;&nbsp; x80000A72
x0022D958:&nbsp;&nbsp;&nbsp; x800F5D37</pre>

<p>Some intermediate questions to help you:</p>

<ul>
<li>What virtual page of P0 Space is <var>X</var> on?</li>
<li>What is VA of the PTE of the page containing <var>X</var>?</li>
<li>What virtual page of System Space is this PTE on?</li>
<li>What is the PA of the PTE of this page of System Space?</li>
<li>What is the PA of the PTE of the page containing <var>X</var>?</li>
</ul>

</li><!-- End Question -->

<li><!-- Begin Question -->
<p>An instruction is said to generate a page fault if a page fault occurs
at any time during the processing of that instruction.</p>

<p>Let's say we added a virtual memory system to the LC-3b. Which
instructions can possibly generate a page fault? What is the maximum
number of page faults an instruction can possibly generate while it is
being processed? Which instructions can possibly generate that maximum
number of page faults? Assume that the virtual memory system added
uses a one-level translation scheme and the page table is always
resident in physical memory.</p>
</li><!-- End Question -->

</ol>
</body>
</html>
