<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>EE 360N: Problem Set 2</title>
<link rel="StyleSheet" type="text/css" href="../../main.css" />
<link rel="StyleSheet" type="text/css" href="../probs.css" />
</head>
<body>
<center>
<h2>
Department of Electrical and Computer Engineering</h2></center>

<center>
<h3>
The University of Texas at Austin</h3></center>
EE 360N, Fall 2009
<br />Problem Set 2
<br />Due: 23 February 2009, before class
<br />Yale N. Patt, Instructor
<br />Ramapriyan Chakravarthy, Khubaib, Vivekanand Venugopal, TAs
<p>Instructions:
You are encouraged to work on the problem set in groups and turn in
one problem set for the entire group. Remember to put all your names on
the solution sheet. <b>Also remember to put the name of the TA in whose discussion
	section you would like the problem set returned to you.</b></p>

<ol class="questions">
<li> <!-- Begin Question -->
<p>
The following program computes the square (<var>k</var>*<var>k</var>) of a positive integer <var>k</var>, stored 
in location <code>0x4000</code> and stores the result in location <code>0x4002</code>.  
The result is to be treated as a 16-bit unsigned number.
</p>  
<p>Assumptions:</p>
<ul>
<li>A memory access takes 5 cycles</li>
<li>The system call initiated by the <code>HALT</code> instruction takes 20 cycles to execute. 
This <strong>does not</strong> include the number of cycles it takes to execute the <code>HALT</code> instruction 
itself.</li> 
</ul>
<pre><code>        .ORIG X3000
        AND R0, R0, #0
        LEA R3, NUM
        LDW R3, R3, #0
        LDW R1, R3, #0        
        ADD R2, R1, #0
LOOP    ADD R0, R0, R1
        ADD R2, R2, #-1
        BRP LOOP          
        STW R0, R3, #1
        HALT
NUM     .FILL x4000
        .END</code></pre>

<ol>
<li>How many cycles does each instruction take to execute on the LC-3b microarchitecture described in Appendix C?</li> 
<li>How many cycles does the entire program take to execute? (answer in terms of <var>k</var>)</li>
<li>What is the maximum value of <var>k</var> for which this program still works correctly? </li>
<li>How will you modify this program to support negative values of <var>k</var>? Explain in less than 30 words. </li> 
<li>What is the new range of <var>k</var>? </li>
</ol>
</li>	
<li> <!-- Begin Question -->
<ol>
<li>In which state(s) in the LC-3b state diagram should the <code>LD.BEN</code> signal be asserted? 
Is there a way for the LC-3b to work correctly without the <code>LD.BEN</code> signal? Explain.</li>
<li>Suppose we want to get rid of the <code>BEN</code> register altogether. Can this be done? 
If so, explain how. If not, why not? Is it a good idea? Explain.</li>
<li>Suppose we took this further and wanted to get rid of state 0. We can do this by 
modifying the microsequencer, as shown in the figure below. What is the 4-bit signal 
denoted as <code>A</code> in the figure? What is the 1-bit signal denoted as <code>B</code>?</li>
</ol>
<img alt="The modified microsequencer logic diagram" src="ms.gif" height="464" width="654" />
</li>
<li>
<p>We wish to use the unused opcode &ldquo;1010&rdquo; to implement a new instruction <code>ADDM</code>, which (similar 
to an IA-32 instruction) adds the contents of a memory location to either the contents of a 
register or an immediate value and stores the result into a register. The specification of this instruction is as follows:
</p>
<h3>Assembler Formats</h3>
ADDM DR, SR1, SR2
<br />
ADDM DR, SR1, imm5
<h3>Encodings</h3>
<img alt="ADDM instruction encoding" src="addm.gif" />
<h3>Operation</h3>
<pre>if (bit[5] == 0)
    DR = Memory[SR1] + SR2;
else
    DR = Memory[SR1] + SEXT(imm5);
setcc(DR);</pre>
<ol>
<li><p>We show below an addition to the state diagram necessary to implement <code>ADDM</code>. Using the notation 
of the LC-3b State Diagram, describe inside each &ldquo;bubble&rdquo; what happens in each state, and assign 
each state an appropriate state number (state <code>A</code> has been done for you). Also, what is the 
one-bit signal denoted as <code>X</code> in the figure? Note: Be sure your solution works when the same 
register is used for both sources and the destination (eg., <code>ADDM R1, R1, R1</code>).
</p>
<img alt="Additional (blank) state sequence for the ADDM instruction" src="addm_state_shrunk.gif" />
</li>
<li><p>Add to the Data Path any additional structures and any additional control signals needed 
to implement <code>ADDM</code>. Label the additional control signals <code>ECS&nbsp;1</code> (for &ldquo;extra control signal 1&rdquo;), 
<code>ECS&nbsp;2</code>, etc.</p></li>
<li><p>The processing in each state <code>A</code>,<code>B</code>,<code>C</code>,<code>D</code> is controlled by asserting or negating each control 
signal. Enter a 1 or a 0 as appropriate for the microinstructions corresponding to states <code>A</code>,<code>B</code>,<code>C</code>,<code>D</code>.
</p>
</li>
</ol>
<img alt="Four empty LC-3b microinstructions" src="addm_ctrl2_65.gif" />
</li> 
<!-- End Question -->

<li> <!-- Begin Question -->
<p>Design the &ldquo;WE Logic&rdquo; block of the LC-3b datapath as shown on Figure C.3 in Appendix C. 
The inputs to the block are <code>MAR[0]</code>, <code>R.W</code>, and <code>DATA.SIZE</code>. The outputs of the block are <code>WE0</code> and <code>WE1</code>. 
Show the truth table for this logic block and give a gate-level implementation.
</p></li>
<!-- End Question -->

<li><!-- Begin Question -->
<p>The Address Control Logic in the LC-3b datapath of Figure C.3 in Appendix C allows the 
LC-3b to support memory-mapped I/O.  There are three inputs to this logic:</p>
<ul>
<li>16-bit address in <code>MAR</code>. This signal can take the following values:
<code>xFE00</code>, <code>xFE02</code>, <code>xFE04</code>, <code>xFE06</code>, and <code>OTHER</code> (any other address between <code>x0000</code>
and <code>xFDFF</code>).</li>
<li>1-bit <code>control</code> signal <code>R.<code>W</code></code>. The access is a read access if this
signal is <code>R</code>, write access if it is <code>W</code>.</li>
<li>1-bit control signal <code>MIO.EN</code>. If this signal is 1, a memory or I/O access
should be performed in this cycle.</li>
</ul>
<p>
The logic has five outputs:</p>
<ul>
<li>1-bit <code>MEM.EN</code> signal. Memory is enabled if this signal is 1.</li>
<li>2-bit select signal for <code>INMUX</code>. This signal can take the following
values: <code>KBDR</code>, <code>KBSR</code>, <code>DSR</code>, <code>MEMORY</code>.</li>
<li>1-bit <code>LD.KBSR</code> signal. <code>KBSR</code> will be load-enabled at the end of the
current cycle if this signal is 1.</li>
<li>1-bit <code>LD.DDR</code> signal.  <code>DDR</code> will be load-enabled at the end of the
current cycle if this signal is 1.</li>
<li>1-bit <code>LD.DSR</code> signal.  <code>DSR</code> will be load-enabled at the end of the
current cycle if this signal is 1. </li>
</ul>

<p>
Your task is to draw the truth table for this Address Control
Logic.  Mark don't care values with &ldquo;X&rdquo; in your truth table. Use the
conventions described above to denote the values of inputs and
outputs. Please read Section C.6 in <a href="../../handouts/360n.appC.pdf">Appendix C</a> 
on memory-mapped I/O before answering this question. Also, refer to 
<a href="../../handouts/new_byte.pdf">Appendix A</a> to find out the addresses of device registers.</p>
</li>
<!-- End Question -->

<!--
<li> <!-- Begin Question -->
<span class="edit_note">Postponed to Problem Set 3.</span>
<p>Consider the following piece of code:</p>
<pre><code>     for(i = 0; i &lt; 8; ++i){
       for(j = 0; j &lt; 8; ++j){
         sum = sum + A[i][j];
       }
     }</code></pre>
<p>The figure below shows an 8-way interleaved, byte-addressable memory.
The total size of the memory is 4KB. The elements of the 2-dimensional
array, <var>A</var>, are 4-bytes in length and are stored in the memory in column-major 
order (i.e., columns of <var>A</var> are stored in consecutive memory locations) as shown. 
The width of the bus is 32 bits, and each memory access takes 10 cycles.
</p>
<img alt="" src="interleave2_bank.jpg" />
<p>
A more detailed picture of the memory chips in Row 0 of Bank 0 is shown below.
</p>
<img alt="" src="interleave_detail.gif" />
<ol>
<li><p>Since the address space of the memory is 4KB, 12 bits are needed to uniquely
identify each memory location, i.e., <code>Addr[11:0]</code>. Specify which bits of the address 
will be used for:</p>
<ul>
<li>Byte on bus<pre>Addr[_____:_____]</pre></li>
<li>Interleave bits<pre>Addr[_____:_____]</pre></li>
<li>Chip address<pre>Addr[_____:_____]</pre></li>
<li>Row decode<pre>Addr[_____:_____]</pre></li>
</ul>
</li>
<li><p>How many cycles are spent accessing memory during the execution of the above code? 
Compare this with the number of memory access cycles it would
take if the memory were not interleaved (i.e., a single 4-byte wide array).</p>
</li>
<li><p>Can any change be made to the current interleaving scheme to optimize the number of 
cycles spent accessing memory? If yes, which bits of the address will be used to specify
the byte on bus, interleaving, etc. (use the same format as in part <i>a</i>)? With 
the new interleaving scheme, how many cycles are spent accessing memory? Remember that 
the elements of <var>A</var> will still be stored in column-major order.</p>
</li>
<li><p>Using the original interleaving scheme, what small changes can be made to the 
piece of code to optimize the number of cycles spent accessing memory? How many
cycles are spent accessing memory using the modified code?</p>
</li>
</ol>
</li>
<!-- End of Question -->

<li> <!-- Begin Question -->
<span class="edit_note">Postponed to Problem Set 3.</span>
<p>The figure below illustrates the logic and
memory to support 512 MB (byte addressable) of physical memory, supporting
unaligned accesses. The ISA contains <code>LDByte</code>, <code>LDHalfWord</code>, <code>LDWord</code>,
<code>STByte</code> , <code>STHalfWord</code> and <code>STWord</code> instructions, where a word is 32 bits. Bit 28 
serves as a chip enable (active high). If this bit is high the data of the 
memory is loaded on the bus, otherwise the output of the memory chip floats (tri-stated).
</p>
<img alt="" src="unaligned_access.gif" height="760" width="690" />
<p>Note: the byte rotators in the figure are right rotators.</p>
<p>Construct the truth table to implement the LOGIC block, having inputs <code>SIZE</code>, <code>R/W</code>, 
1st or 2nd access, <code>PHYS_ADDR[1:0]</code> and the outputs shown in the above figure. Assume 
that the value of <code>SIZE</code> can be <code>Byte</code> (<code>00</code>), <code>HalfWord</code> (<code>01</code>), and <code>Word</code> (<code>10</code>). Clearly 
explain what function each output serves.</p>
</li>

<li>
<p>The LC-3b state diagram handed out in class contained errors in states 4, 20, and 21. We have posted both versions of the handout: <a href="state_wrong.pdf">wrong</a> and <a href="../../handouts/state_fixed.pdf">corrected</a>. Briefly explain the problem we have corrected.</p>
</li>
-->
<li><p>Answer the following short questions:</p>
	<ol>
	  <li><p>A memory's addressability is 64 bits. What does that tell you about the sizes of the MAR and the MDR?</p></li>
	  <li><p>We want to increase the number of registers that we can specify in the LC-3b ADD instruction to 32. Do you see any problem with that? Explain.</p></li>
	</ol> 
</li>
</ol>

</body>
</html>
