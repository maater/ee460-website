<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <title>EE 460N: Problem Set 2</title>
    <link rel="StyleSheet" type="text/css" href="../../main.css" />
    <link rel="StyleSheet" type="text/css" href="../probs.css" />
  </head>
  <body>
    <center>
      <h2>
        Department of Electrical and Computer Engineering</h2></center>

    <center>
      <h3>
        The University of Texas at Austin</h3></center>
    EE 460N, Spring 2013
    <br />Problem Set 2
    <br />Due: February 18, before class
    <br />Yale N. Patt, Instructor
    <br />Faruk Guvenilir, Sumedha Bhangale, Stephen Pruett, TAs
    <p>Instructions:
    You are encouraged to work on the problem set in groups and turn in
    one problem set for the entire group. Remember to put all your names on
    the solution sheet. <b>Also remember to put the name of the TA in whose discussion
      section you would like the problem set returned to you.</b></p>

    <ol class="questions">

<li><p>
The ISA is the contract between the hardware and the software. The microarchitecture is a particular implementation of an ISA. 
Compiler does not need to know any information about the microarchitecture.</p>
  <ol>
  <li>ISA</li>
  <li>Microarchitecture</li>
  <li>ISA</li>
  <li>Microarchitecture</li>
  <li>ISA</li>
  <li>Microarchitecture/ISA</li>
  <li>ISA</li>
  <li>Microarchitecture</li>
  <li>Microarchitecture</li>
  <li>Microarchitecture</li>
</ol>
</li>
<li>
<ol>
<li>The first option does not support either subroutine nesting or subroutine recursion.</li>
<li>The second option supports subroutine nesting, but does not support recursion.</li>
<li>The third option supports both subroutine nesting and subroutine recursion.</li>
</ol>
</li>
<li>
<ol>
<li>Little endian: <span class="equation">MEM[<code>x1000</code>] + MEM[<code>x1002</code>] = <code>x1A0E</code> + <code>x0C11</code> = <code>x261F</code></span></li>
<li>Big endian:    <span class="equation">MEM[<code>x1000</code>] + MEM[<code>x1002</code>] = <code>x0E1A</code> + <code>x110C</code> = <code>x1F26</code></span></li>
</ol>
</li>
      <li> <!-- Begin Question -->
      <p>
      The following program computes the square (<var>k</var>*<var>k</var>) of a positive integer <var>k</var>, stored 
      in location <code>0x4000</code> and stores the result in location <code>0x4002</code>.  
      The result is to be treated as a 16-bit unsigned number.
      </p>  
      <p>Assumptions:</p>
      <ul>
        <li>A memory access takes 5 cycles</li>
        <li>The system call initiated by the <code>HALT</code> instruction takes 20 cycles to execute. 
        This <strong>does not</strong> include the number of cycles it takes to execute the <code>HALT</code> instruction 
        itself.</li> 
      </ul>
<pre><code>        .ORIG X3000
        AND R0, R0, #0
        LEA R3, NUM
        LDW R3, R3, #0
        LDW R1, R3, #0        
        ADD R2, R1, #0
LOOP    ADD R0, R0, R1
        ADD R2, R2, #-1
        BRP LOOP          
        STW R0, R3, #1
        HALT
NUM     .FILL x4000
        .END</code></pre>

      <ol>
        <li>How many cycles does each instruction take to execute on the LC-3b microarchitecture described in Appendix C?</li> 
        <li>How many cycles does the entire program take to execute? (answer in terms of <var>k</var>)</li>
        <li>What is the maximum value of <var>k</var> for which this program still works correctly? </li>
        <li>How will you modify this program to support negative values of <var>k</var>? Explain in less than 30 words. </li> 
        <li>What is the new range of <var>k</var>? </li>
      </ol>
      </li>	
      <li> <!-- Begin Question -->
      <ol>
        <li>In which state(s) in the LC-3b state diagram should the <code>LD.BEN</code> signal be asserted? 
        Is there a way for the LC-3b to work correctly without the <code>LD.BEN</code> signal? Explain.</li>
        <li>Suppose we want to get rid of the <code>BEN</code> register altogether. Can this be done? 
        If so, explain how. If not, why not? Is it a good idea? Explain.</li>
        <li>Suppose we took this further and wanted to get rid of state 0. We can do this by 
        modifying the microsequencer, as shown in the figure below. What is the 4-bit signal 
        denoted as <code>A</code> in the figure? What is the 1-bit signal denoted as <code>B</code>?</li>
      </ol>
      <img alt="The modified microsequencer logic diagram" src="ms.gif" height="464" width="654" />
      </li>
      <li>
      <p>We wish to use the unused opcode &ldquo;1010&rdquo; to implement a new instruction <code>ADDM</code>, which (similar 
      to an IA-32 instruction) adds the contents of a memory location to either the contents of a 
      register or an immediate value and stores the result into a register. The specification of this instruction is as follows:
      </p>
      <h3>Assembler Formats</h3>
      ADDM DR, SR1, SR2
      <br />
      ADDM DR, SR1, imm5
      <h3>Encodings</h3>
      <img alt="ADDM instruction encoding" src="addm.gif" />
      <h3>Operation</h3>
<pre>if (bit[5] == 0)
    DR = Memory[SR1] + SR2;
else
    DR = Memory[SR1] + SEXT(imm5);
setcc(DR);</pre>
      <ol>
        <li><p>We show below an addition to the state diagram necessary to implement <code>ADDM</code>. Using the notation 
        of the LC-3b State Diagram, describe inside each &ldquo;bubble&rdquo; what happens in each state, and assign 
        each state an appropriate state number (state <code>A</code> has been done for you). Also, what is the 
        one-bit signal denoted as <code>X</code> in the figure? Note: Be sure your solution works when the same 
        register is used for both sources and the destination (eg., <code>ADDM R1, R1, R1</code>).
        </p>
        <img alt="Additional (blank) state sequence for the ADDM instruction" src="addm_state_shrunk.gif" />
        </li>
        <li><p>Add to the Data Path any additional structures and any additional control signals needed 
        to implement <code>ADDM</code>. Label the additional control signals <code>ECS&nbsp;1</code> (for &ldquo;extra control signal 1&rdquo;), 
        <code>ECS&nbsp;2</code>, etc.</p></li>
        <li><p>The processing in each state <code>A</code>,<code>B</code>,<code>C</code>,<code>D</code> is controlled by asserting or negating each control 
        signal. Enter a 1 or a 0 as appropriate for the microinstructions corresponding to states <code>A</code>,<code>B</code>,<code>C</code>,<code>D</code>.
        </p>
        </li>
      </ol>
      <img alt="Four empty LC-3b microinstructions" src="addm_ctrl2_65.gif" />
      </li> 
      <!-- End Question -->

      <li> <!-- Begin Question -->
      <p>Design the &ldquo;WE Logic&rdquo; block of the LC-3b datapath as shown on Figure C.3 in Appendix C. 
      The inputs to the block are <code>MAR[0]</code>, <code>R.W</code>, and <code>DATA.SIZE</code>. The outputs of the block are <code>WE0</code> and <code>WE1</code>. 
      Show the truth table for this logic block and give a gate-level implementation.
      </p></li>
      <!-- End Question -->

      <li><!-- Begin Question -->
      <p>The Address Control Logic in the LC-3b datapath of Figure C.3 in Appendix C allows the 
      LC-3b to support memory-mapped I/O.  There are three inputs to this logic:</p>
      <ul>
        <li>16-bit address in <code>MAR</code>. This signal can take the following values:
        <code>xFE00</code>, <code>xFE02</code>, <code>xFE04</code>, <code>xFE06</code>, and <code>OTHER</code> (any other address between <code>x0000</code>
        and <code>xFDFF</code>).</li>
        <li>1-bit <code>control</code> signal <code>R.<code>W</code></code>. The access is a read access if this
        signal is <code>R</code>, write access if it is <code>W</code>.</li>
        <li>1-bit control signal <code>MIO.EN</code>. If this signal is 1, a memory or I/O access
        should be performed in this cycle.</li>
      </ul>
      <p>
      The logic has five outputs:</p>
      <ul>
        <li>1-bit <code>MEM.EN</code> signal. Memory is enabled if this signal is 1.</li>
        <li>2-bit select signal for <code>INMUX</code>. This signal can take the following
        values: <code>KBDR</code>, <code>KBSR</code>, <code>DSR</code>, <code>MEMORY</code>.</li>
        <li>1-bit <code>LD.KBSR</code> signal. <code>KBSR</code> will be load-enabled at the end of the
        current cycle if this signal is 1.</li>
        <li>1-bit <code>LD.DDR</code> signal.  <code>DDR</code> will be load-enabled at the end of the
        current cycle if this signal is 1.</li>
        <li>1-bit <code>LD.DSR</code> signal.  <code>DSR</code> will be load-enabled at the end of the
        current cycle if this signal is 1. </li>
      </ul>

      <p>
      Your task is to draw the truth table for this Address Control
      Logic.  Mark don't care values with &ldquo;X&rdquo; in your truth table. Use the
      conventions described above to denote the values of inputs and
      outputs. Please read Section C.6 in <a href="../../handouts/360n.appC.pdf">Appendix C</a> 
      on memory-mapped I/O before answering this question. Also, refer to 
      <a href="../../handouts/new_byte.pdf">Appendix A</a> to find out the addresses of device registers.</p>
      </li>
      <!-- End Question -->

      <li>
      <!-- Begin Question -->
      <!--
<li><font color="red" size="-1">Postponed until Problem Set 3.</font>
<p>Consider the following piece of code:</p>
<pre><code>     for(i = 0; i &lt; 8; ++i){
       for(j = 0; j &lt; 8; ++j){
         sum = sum + A[i][j];
       }
     }</code></pre>
<p>The figure below shows an 8-way interleaved, byte-addressable memory.  The
total size of the memory is 4KB. The elements of the 2-dimensional array,
<var>A</var>, are 4-bytes in length and are stored in the memory in
column-major order (i.e., columns of <var>A</var> are stored in consecutive
memory locations) as shown.  The width of the bus is 32 bits, and each memory
access takes 10 cycles.  </p>
<img alt="" src="interleave2_bank.jpg" />
<p>
A more detailed picture of the memory chips in Row 0 of Bank 0 is shown below.
</p>
<img alt="" src="interleave_detail.gif" />
<ol>
<li><p>Since the address space of the memory is 4KB, 12 bits are needed to
uniquely identify each memory location, i.e., <code>Addr[11:0]</code>. Specify
which bits of the address will be used for:</p>
<ul>
<li>Byte on bus<pre>Addr[_____:_____]</pre></li>
<li>Interleave bits<pre>Addr[_____:_____]</pre></li>
<li>Chip address<pre>Addr[_____:_____]</pre></li>
<li>Row decode<pre>Addr[_____:_____]</pre></li>
</ul>
</li>
<li><p>How many cycles are spent accessing memory during the execution of the above code? 
Compare this with the number of memory access cycles it would
take if the memory were not interleaved (i.e., a single 4-byte wide array).</p>
</li>
<li><p>Can any change be made to the current interleaving scheme to optimize the number of 
cycles spent accessing memory? If yes, which bits of the address will be used to specify
the byte on bus, interleaving, etc. (use the same format as in part <i>a</i>)? With 
the new interleaving scheme, how many cycles are spent accessing memory? Remember that 
the elements of <var>A</var> will still be stored in column-major order.</p>
</li>
<li><p>Using the original interleaving scheme, what small changes can be made to the 
piece of code to optimize the number of cycles spent accessing memory? How many
cycles are spent accessing memory using the modified code?</p>
</li>
</ol>
--!>
<!-- End Question -->
</li>

<li>
<!-- Begin Question -->
<!--
<li><font color="red" size="-1">Postponed until Problem Set 3.</font>
<p>The figure below illustrates the logic and
memory to support 512 MB (byte addressable) of physical memory, supporting
unaligned accesses. The ISA contains <code>LDByte</code>, <code>LDHalfWord</code>, <code>LDWord</code>,
<code>STByte</code> , <code>STHalfWord</code> and <code>STWord</code> instructions, where a word is 32 bits. Bit 28 
serves as a chip enable (active high). If this bit is high the data of the 
memory is loaded on the bus, otherwise the output of the memory chip floats (tri-stated).
</p>
<img alt="" src="unaligned_access.gif" height="760" width="690" />
<p>Note: the byte rotators in the figure are right rotators.</p>
<p>Construct the truth table to implement the LOGIC block, having inputs <code>SIZE</code>, <code>R/W</code>, 
1st or 2nd access, <code>PHYS_ADDR[1:0]</code> and the outputs shown in the above figure. Assume 
that the value of <code>SIZE</code> can be <code>Byte</code> (<code>00</code>), <code>HalfWord</code> (<code>01</code>), and <code>Word</code> (<code>10</code>). Clearly 
explain what function each output serves.</p>
--!>
</li>
<!-- End Question -->


<!-- Begin Question -->
<li>
<p>The LC-3b state diagram handed out in class contained errors in states 4, 20, and 21. We have posted both versions of the handout: <a href="state_wrong.pdf">wrong</a> and <a href="../../handouts/state_fixed.pdf">corrected</a>. Briefly explain the problem we have corrected.</p>
</li>
<!-- End Question -->

<!-- Begin Question -->
<li><p>Answer the following short questions:</p>
<ol>
  <li><p>A memory's addressability is 64 bits. What does that tell you about the sizes of the MAR and the MDR?</p></li>
  <li><p>We want to increase the number of registers that we can specify in the LC-3b ADD instruction to 32. Do you see any problem with that? Explain.</p></li>
</ol> 
</li>
<!-- End Question -->

<li id="scoreboard"><!-- Begin Question -->
<p>Given the following code:</p>

<pre><code>MUL R3, R1, R2
ADD R5, R4, R3
ADD R6, R4, R1
MUL R7, R8, R9
ADD R4, R3, R7
</code>MUL R10, R5, R6</pre>

<p>Note: Each instruction is specified with the destination register first.</p>

<p>Calculate the number of cycles it takes to execute the given code on the 
following models:</p>

<ol type="a">
  <li>A non-pipelined machine.</li>
  <li>A pipelined machine with scoreboarding and five adders and five multipliers.</li>
  <li>A pipelined machine with scoreboarding and one adder and one multiplier.</li>
</ol>

<p>Note: For all machine models, use the basic instruction cycle as follows:</p>
<ul>
  <li>Fetch (one clock cycle)</li>
  <li>Decode (one clock cycle)</li>
  <li>Execute (MUL takes 6, ADD takes 4 clock cycles). The multiplier and the adder are not pipelined.</li>
  <li>Write-back (one clock cycle)</li>
</ul>

<p>Do not forget to list any assumptions you make about the pipeline
structure (e.g., data forwarding between pipeline stages). Infact, we encourage
you to solve the above mentioned questions with data forwarding as well, but,
you are not required to do so.</p>
</li>
<!-- End Question -->
<!-- Begin Question -->
<li id="branch_prediction">
<p>Suppose we have the following loop executing on a pipelined LC-3b machine.</p>

<pre><code>DOIT     STW   R1, R6, #0
         ADD   R6, R6, #2
         AND   R3, R1, R2
         BRz   EVEN
         ADD   R1, R1, #3
         ADD   R5, R5, #-1
         BRp   DOIT
EVEN     ADD   R1, R1, #1
         ADD   R7, R7, #-1 
         BRp   DOIT</code></pre>

<p>Assume that before the loop starts, the registers have the following
<strong>decimal</strong> values stored in them:</p>
<table>
  <thead>
    <tr><th>Register</th><th>Value</th></tr>
  </thead>
  <tbody>
    <tr><td>R0</td><td>0</td></tr>
    <tr><td>R1</td><td>0</td></tr>
    <tr><td>R2</td><td>1</td></tr>
    <tr><td>R3</td><td>0</td></tr>
    <tr><td>R4</td><td>0</td></tr>
    <tr><td>R5</td><td>5</td></tr>
    <tr><td>R6</td><td>4000</td></tr>
    <tr><td>R7</td><td>5</td></tr>
  </tbody>
</table>

<p>The fetch stage takes one cycle, the decode stage also takes one cycle, the execute stage takes 
a variable number of cycles depending on the type of instruction (see below), and the store stage takes one cycle.</p>

<p>All execution units (including the load/store unit) are fully pipelined and 
the following instructions that use these units take the indicated number of 
cycles:</p>

<table>
  <thead>
    <tr><th>Instruction</th><th>Number of Cycles</th></tr>
  </thead>
  <tbody>
    <tr><td>STW</td><td>3</td></tr> 
    <tr><td>ADD</td><td>3</td></tr> 
    <tr><td>AND</td><td>2</td></tr> 
    <tr><td>BR</td><td>1</td></tr>
  </tbody>
</table>

<p>Data forwarding is used wherever possible. Instructions that are
dependent on the previous instructions can make use of the results
produced right after the previous instruction finishes the
execute stage.</p>
<p>The target instruction after a branch can be fetched when the
BR instruction is in ST stage. For example, the execution of an ADD instruction followed by a BR would look 
like:</p>

<pre>ADD       F | D | E1 | E2 | E3 | ST
BR            F | D  | -  | -  | E1 | ST
TARGET                                F  | D</pre>

<p>The pipeline implements &ldquo;in-order execution.&rdquo; A scoreboarding scheme is used 
as discussed in class.</p>

<p>Answer the following questions:</p>
<ol type="a">
  <li><p>How many cycles does the above loop take to execute if no branch prediction is used?</p></li>
  <li><p>How many cycles does the above loop take to execute if all branches are predicted with 100% accuracy.</p></li>
  <li><p>How many cycles does the above loop take to execute if a static BTFN (backward taken-forward not taken) branch prediction scheme is used to predict branch directions? What is the overall branch prediction accuracy? What is the prediction accuracy for each branch?</p></li>
</ol>
</li>
<!-- End Question -->
<li>
<!-- Begin Question -->
<!--
<li><p>A five instruction sequence executes according to Tomasulo's
algorithm. Each instruction is of the form <code>ADD DR,SR1,SR2</code> or <code>MUL
  DR,SR1,SR2</code>.  ADDs are pipelined and take 9 cycles
(F-D-E1-E2-E3-E4-E5-E6-WB).  MULs are also pipelined and take 11 cycles (two
extra execute stages).  The microengine must wait until a result is in
a register before it sources it (reads it as a source operand).</p>

<p>The register file before and after the sequence are shown
below (tags for &ldquo;After&rdquo; are ignored).</p>

<img src="Table1.jpg" alt="Two register file before and after the instruction sequence" />

<ol type="a">
  <li> 
  <p>Complete the five instruction sequence in program order in the space below.
  Note that we have helped you by giving you the opcode and two source operand
  addresses for instruction 4. (The program sequence is unique.)</p>

  <img src="Table2.jpg" alt="Space to fill in the five instruction sequence with part of one instruction given" />
  </li>
  <li>
  <p>In cycle 1 instruction 1 is fetched.  In cycle 2,
  instruction 1 is decoded and instruction 2 is fetched.  In cycle 3,
  instruction 1 starts execution, instruction 2 is decoded, and
  instruction 3 is fetched.</p>

  <p>Assume the reservation stations are
  all initially empty. Put each instruction into the next available
  reservation station. For example, the first ADD goes into &ldquo;a&rdquo;. The
  first MUL goes into &ldquo;x&rdquo;. Instructions remain in the reservation
  stations until they are completed. Show the state of the reservation
  stations at the end of cycle 8.</p>

  <p>Note: to make it easier for the grader, when allocating source registers
  to reservation stations, please always have the higher numbered register be
  assigned to SR2.</p>

  <img src="Table3.jpg" alt="Two empty reservation stations, one for the adder and one for the multiplier" />
  </li>
  <li>
  <p>Show the state of the Register Alias Table (V, tag, Value) at the end of
  cycle 8.</p>

  <img src="Table4.jpg" alt="Empty Register Alias Table" />
  </li>
</ol>
--!>
</li>
<!-- End Question -->
</ol>
<li>
<p>The states could be state nos 20 and 12 when you are loading PC from the register. Although the '0' offset can be acquired from the instruction as well using the least 6 significant bits</p>
</li>

</body>
</html>
