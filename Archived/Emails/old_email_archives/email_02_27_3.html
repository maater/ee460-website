<!-- commenting the email tags out .... 
From patt@login.hps.utexas.edu  Sun Feb 27 05:45:33 2011
Return-Path: <patt@login.hps.utexas.edu>
Received: from login.hps.utexas.edu (login.hps.utexas.edu [128.83.178.4])
	by ego.hps.utexas.edu (8.13.8/8.13.8) with ESMTP id p1RBjXuR005202;
	Sun, 27 Feb 2011 05:45:33 -0600
Received: from login.hps.utexas.edu (localhost.localdomain [127.0.0.1])
	by login.hps.utexas.edu (8.13.8/8.13.8) with ESMTP id p1RBjVed022735;
	Sun, 27 Feb 2011 05:45:31 -0600
Received: (from patt@localhost)
	by login.hps.utexas.edu (8.13.8/8.13.8/Submit) id p1RBjVP2022734;
	Sun, 27 Feb 2011 05:45:31 -0600
Date: Sun, 27 Feb 2011 05:45:31 -0600
From: "Yale N. Patt" <patt@ece.utexas.edu>
To: miladhashemi@gmail.com, faruk@hps.utexas.edu, yuhao.zhu@mail.utexas.edu
Subject: the memory cycle
End comment here .... --> 
<HTML>
<HEAD>
<TITLE>EE 460N: Email Sun, 27 Feb 2011, 05:45</TITLE>
</HEAD>
<BODY TEXT="black" BGCOLOR="white" LINK="green" VLINK="purple" ALINK="#0000EE">
<H1></H1>
<p><font size=+1>Sun, 27 Feb 2011, 05:45</font>
<p><pre>
<font color="blue">
I have gotten a few emails today regarding the memory cycle, so I thought
I would try to answer it in one blanket email.  Let's look for example at
the three states needed to complete the LDB instruction, states 2, 29, and 31.
If you have no problem with that, feel free to delete this message and move on.

For those of you who are still struggling with this, I hope the following
helps.

We are trying to simulate a memory system where a memory access takes five 
cycles.  That is, if we say "read memory" at the start of cycle 1, the data
will be available to be latched into MDR at the end of cycle 5.  If we had
the actual memory, we would install a ready signal that would be asserted at
the end of cycle 4 so that the microsequencer could use it during cycle 5 to
move on to the next state.  Unfortunately, we do not have the luxury of a 
memory running autonomously with our processor.  So, we use a global counter
to create the same effect.

Now then, let's look at our three states 2, 29, and 31.  State 2 is for loading
MAR, state 29 for reading memory, ending with the contents in MDR, and state
31 for transferring data from MDR to the designated gpr.

In clock cycle 1, we load MAR.  While that is going on, the microsequencer
generates the next address 29, accesses the control store, and at the end of
clock cycle 1, latches the microinstruction of state 29 into the 
microinstruction register.

This microinstruction must execute 5 consecutive times.  It executes in
cycle n if the microsequencer determines it should in cycle n-1.  The 5th time
it executes, it loads MDR with the contents of memory, while in the same clock
cycle, the microsequencer determines that the next clock cycle, state 31
should execute.

To make this happen, we need R, the ready bit, initially R=0.  We need a global
counter, also initially at 0.  We need a function that will execute every time 
state 29 is active.  This function will need to keep track of how many times 
state 29 has executed so as to properly update the counter, R, and MDR. 

I hope the above is helpful.  Good luck finishing the lab tonight.

Yale Patt

</font>
</pre>
</body>
</html>
