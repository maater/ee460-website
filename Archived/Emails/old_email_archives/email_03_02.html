<!-- commenting the email tags out .... 
From patt@login.hps.utexas.edu  Wed Mar  2 01:37:56 2011
Return-Path: <patt@login.hps.utexas.edu>
Received: from login.hps.utexas.edu (login.hps.utexas.edu [128.83.178.4])
	by ego.hps.utexas.edu (8.13.8/8.13.8) with ESMTP id p227buTa010740;
	Wed, 2 Mar 2011 01:37:56 -0600
Received: from login.hps.utexas.edu (localhost.localdomain [127.0.0.1])
	by login.hps.utexas.edu (8.13.8/8.13.8) with ESMTP id p227bsi1017055;
	Wed, 2 Mar 2011 01:37:54 -0600
Received: (from patt@localhost)
	by login.hps.utexas.edu (8.13.8/8.13.8/Submit) id p227bssv017053;
	Wed, 2 Mar 2011 01:37:54 -0600
Date: Wed, 2 Mar 2011 01:37:54 -0600
From: "Yale N. Patt" <patt@ece.utexas.edu>
To: miladhashemi@gmail.com, faruk@hps.utexas.edu, yuhao.zhu@mail.utexas.edu
Subject: A student is preparing for the mid-term...
End comment here .... --> 
<HTML>
<HEAD>
<TITLE>EE 460N: Email Wed, 2 Mar 2011, 01:37</TITLE>
</HEAD>
<BODY TEXT="black" BGCOLOR="white" LINK="green" VLINK="purple" ALINK="#0000EE">
<H1></H1>
<p><font size=+1>Wed, 2 Mar 2011, 01:37</font>
<p><pre>
<font color="blue">
A student writes:
<font color="black">
&gt; Dear Prof Patt,
&gt; While I was preparing for your exam &amp; was going through the materials 
&gt; already covered in class, I had some doubts in mind:
&gt; 
&gt; 1) x86 you said is a variable length Instruction. Is the semantic GAP 
&gt; for x86 large or small? If it is large, why does the hardware have to 
&gt; do so much work?
</font>

The semantic gap is a colorful term used to describe how close high level
language statements are implemented by a single ISA instruction.  Of all
the ISAs I have encountered, VAX had the smallest semantic gap.  x86's gap
is certainly smaller than SPARC, MIPS, Power-PC, given the complexity of an
addressing mode that can be implemented in one x86 instruction, plus the
LOOP prefix which allows the one instruction to execute multiple times.
<font color="black">
&gt; 2) Is x86 is a VLIW as well?
</font>

Where did this come from?  No, VLIW (more on them after Spring break) are
fixed-length instructions made up of a fixed number of pieces, such that an 
entire VLIW instruction's pieces are all fetched, decoded and executed in 
lock step.  It has nothing meaningful to do with x86.
<font color="black">
&gt; 3) You mentioned in class that nowadays 4 instructions are fetched at a
&gt; time. What happens to these four instructions? Are they sent over different
&gt; pipelines? If not, how does fetching  more at a time help?
</font>

Absolutely, if you only have one pipeline, then fetching more at a time does
not help.  You would have an unbalanced design.  Recall that a balanced design
is an important quality to have in a design.  What you have is the ability
to fetch 4 at a time, and decode 4 at a time.  If the instructions are to be
executed in program order, then you would need to continue to carry the 4 at 
a time through to the store result phase.  If the instructions are to be
executed out-of-order (as we showed in class, like the Tomasulo algorithm),
then we need to replicate the pipeline up to the point where the instructions
are sent to the reservation stations.  From the reservation stations, all 
instructions compete for all the functional units, so you can continue to see 
4 at a time being processed, provided you have at least 4 functional units, 
which all chips that fetch four at a time do these days.
<font color="black">
&gt; 4) in the Physical Memory handout, at one place you mention "Bits of 
&gt; Address that do NOT go to the memory" &amp; in Interleaving you mention, 
&gt; "Bits on the Bus" in some LSB bits of the address. Maybe I am missing 
&gt; something basic, but can you please let me know what bits they are?
</font>

The two "places" you speak of are consistent.  The LSB bits of the address
that I have labeled "Bits on the bus" are the bits that differentiate the
different bytes that are on the bus at the same time.  These bits are not
sent to the memory.

Perhaps an example will make this more clear.  Suppose the bus was 32 bits, 
and memory was byte addressable.  Suppose we want to read one byte, the 
contents of x4001.  We would send to memory the address bits[15:2], that is
0100 0000 0000 00.  Note that we have only sent 14 bits of address, and have 
not sent bits[1:0].  Memory would transfer on the 32-bit bus the contents of 
x4000, x4001, x4002, and x4003, the four addresses that have the specified
bits[15:2] in their addresses.

At the processor side, of course we need all 16 address bits so we can 
identify what we need from among everything that comes in on the 32-bit bus. 
In this case, we need x4001, which is differentiated by bits[1:0].
<font color="black">
&gt; Thanks,
&gt; &lt;&lt;name withheld to protect the student who is preparing for the mid-term&gt;&gt;
</font>

OK?
Good luck on the exam.
Yale Patt

</font>
</pre>
</body>
</html>
